\documentclass[00-praca-magisterska.tex]{subfiles}
\begin{document}

\chapter{Weryfikacja}

\FIXME{Rozpocząć od wstępu, w którym odpisany jest proces weryfikacji naszego programu. Coś o wydajności, użyteczności, testowaniu itd.}

\FIXME{Napisać o unit-testach.}

\section{Dostępne rozwiązania}
\label{dostepne-rozwiazania}

\FIXME{gdzies te sekcje ustawic w dobrym miejscu...}

Istnieje wiele programów rozwiązujących problem automatyzacji testowania, które
w różnym stopniu i na różnych poziomach pozwalają na ułatwienie i przyspieszenie
przeprowadzania testów aplikacji i protokołów sieciowych. Jednak spośród znanych
nam rozwiązań, żadne nie pozwalało przeprowadzić takiego rodzaju testów, jakie
próbowaliśmy wykonać.

\subsection{ASN.1 i ECN}
\label{asn}
ASN.1 (Abstract Syntax Notation One) jest to standard ITU-T/ISO służący do opisu
struktur reprezentujących dane w sposób umożliwiający ich kodowanie, transmisję
i dekodowanie. Dostarcza on formalnej notacji do opisu struktur w sposób
niezwiązany z reprezentacją sprzętową.

ASN.1 definiuje sposób opisu danych. Jest on niezależny od metod ich kodowania,
przedstawionych w oddzielnych dokumentach. Przykładowe metody to:
\begin{itemize}
\item BER (Basic Encoding Rules),
\item PER (Packed Encoding Rules),
\item XER (XML Encoding Rules).
\end{itemize}

Wykorzystanie formalnych metod opisu pozwala na automatyczne tworzenie koderów i
dekoderów. W przypadku pracy z istniejącymi protokołami, PDU zwykle na stałe
wiąże przenoszone dane z ich kodowaniem. Przykładem może być opis pakietów TCP w
RFC 793, gdzie dane (np. numer sekwencyjny) i ich kodowanie (rozmiar i
położenie bitów w pakiecie) określone są w tym samym miejscu. Nie ma więc
podziału między semantyką informacji i jej bitową reprezentacją. Korzystanie z
ASN.1 w takich wypadkach jest trudniejsze, ale możliwe dzięki ECN.

ECN (Explicit Coding Notation) umożliwia formalny opis niestandardowych metod
kodowania. Jest to standard ściśle związany z ASN.1 i opis danego kodowania
zawsze łączy się z pewnym opisem danych wyrażonych w ASN.1. Z tego powodu często
spotyka się określenie ASN.1+ECN.

\subsubsection{Przykład}

Prezentujemy tutaj proste przykłady użycia ASN.1 oraz ASN.1+ECN. Zostały one
pobrane z materiałów szkoleniowych dostępnych w internecie \cite{asn1-main,ecn-tutorial1,ecn-tutorial2,ecn-tutorial3}.

Poniżej definiujemy prosty protokół składający się z jednego typu PDU:
(\code{Message}). Wiadomość zbudowana jest z identyfikatora oraz jej
zawartości, będącej napisem zakodowanym w UTF-8.

\begin{textcode}
  Protocol DEFINITIONS ::= BEGIN
       Message::= SEQUENCE {
          identifier INTEGER,
          content    UTF8String
      }
  END
\end{textcode}

Taka definicja, po wybraniu kodowania, może zostać użyta do wygenerowania
odpowiednich koderów i dekoderów, aby następnie użyć jej w tworzonej aplikacji.
Dekoder zgłaszający wszelkie napotkane błędy jest doskonałym narzędziem do
przetestowania pracy innego uczestnika komunikacji (którego poprawną
implementację chcemy zweryfikować).

PDU powyższego protokołu może mieć taką postać:

\begin{textcode}
  sampleMessage Message ::= {
      identifier     3,
      content        "Hello!"
  }
\end{textcode}

Istotną cechą ASN.1 jest odseparowanie definicji danych od ich kodowania.
Dzięki temu możliwe jest zakodowanie tych samych informacji na różne sposoby. I
tak np. możemy użyć kodowania XER uzyskując poniższy XML:

\begin{xmlcode}
  <Message>
      <identifier>3</identifier>
      <content>Hello!</content>
  </FooQuestion>
\end{xmlcode}

Czasem żadne z dostępnych, uniwersalnych, kodowań nie będzie odpowiadać naszym
wymaganiom. Dzieje się tak najczęściej w przypadku protokołów sztywno
definiujących sposób kodowania informacji, jak np. wspomniany wcześniej TCP. W
takich wypadkach możemy zastosować ECN.

ECN dostarcza mechanizmów do zdefiniowania dowolnego sposobu kodowania
informacji. Załóżmy, że w PDU naszego protokołu występuje liczba przyjmująca
wartości od 0 do 7 i używamy kodowania PER. Taka liczba zostałaby zakodowana
korzystając z 3 bitów. Ze względu jednak na przewidywaną możliwość rozwoju
chcemy aby zakodowana ona była na 5 bitach. Oto jak możemy to zrobić przy
pomocy ECN.

Najpierw definicja typu w ASN.1:

\begin{textcode}
  Example-ASN1 DEFINITIONS AUTOMATIC TAGS ::=
  BEGIN
    MyType ::= INTEGER (0..7)
  END
\end{textcode}

A następnie definicja kodowania w ECN:

\begin{textcode}
  Example-EDM ENCODING-DEFINITIONS ::=
  BEGIN
  
  IMPORTS
    #MyType
  FROM Example-ASN1;
  
  MyEncodings #ENCODINGS ::= { myType-encoding }
  
  myType-encoding #MyType ::= {
    ENCODING {
      ENCODING-SPACE
      SIZE 5
      MULTIPLE OF bit
      ENCODING positive-int
    }
  }
  END
\end{textcode}

Aby tej definicji użyć potrzebny jest jeszcze moduł łączący zdefiniowane kodowanie z definicją w ASN:

\begin{textcode}
  Example-ELM LINK-DEFINITIONS ::=
  BEGIN
  
  IMPORTS
    #MyType
  FROM Example-ASN1
    MyEncodings
  FROM Example-EDM;
  
  ENCODE #MyType
    WITH          MyEncodings
    COMPLETED BY  PER-BASIC-UNALIGNED
  END
\end{textcode}

Instrukcja \code{COMPLETED BY} powoduje, że do pozostałych danych zostaną użyte
standardowe reguły kodowania PER.

Oczywiście możliwości ECN są o wiele większe i biorą pod uwagę wszystkie
spotykane w praktyce sposoby kodowania złożonych struktur, jak określanie
sposobu budowania sekwencji, wybierania typu opcji, obliczanie sum kontrolnych,
wprowadzanie wyrównań, itd.

\subsubsection{Podsumowanie}

Język ASN.1 doskonale nadaje się do tworzenia dokumentacji, z której następnie
automatycznie można generować kodery i dekodery. Dzięki temu potrzebny do
testowania parser otrzymujemy niemal zerowym kosztem.

Uważamy, że jest to jedna z technologii, która z powodzeniem może być użyta do
przeprowadzania pierwszego rodzaju testów, badających poprawność PDU.

\subsection{TTCN}
\label{ttcn}

TTCN-3 (Testing \& Test Control Notation v.~3) to język skryptowy stworzony i
rozwijany przez grupę TC-MTS (Methods for Testing and Specification Technical
Committee) w ramach ETSI \cite{ttcn-main}.

Język swoimi korzeniami (TTCN-2) sięga do lat 80 minionego wieku. Wersja 3
została zaprojektowana z myślą o tych samych zastosowaniach, korzystając z wielu
lat doświadczeń, porzucono jednak sporo archaicznych rozwiązań (wprowadzono
m.in. nową składnię). Dzisiaj TTCN to język używany od ponad 15 lat w procesach
standaryzacji i przemyśle. Użyty został np. w czasie prac nad SIP i WiMAX.

TTCN-3 najlepiej sprawdza się w testach zgodności systemów komunikacyjnych
postrzeganych jako czarne skrzynki. Nie był projektowany z myślą o testach
wydajnościowych, chociaż obecnie projektowane są rozszerzenia mające na celu
zaadresować tego typu zastosowania.

\subsubsection{System testowy TTCN-3}

Testowanie przy użyciu TTCN-3 opiera się na wykonywaniu zaimplementowanych
komponentów, które, działając w interakcji z testowanych systemem, obserwują
komunikację i zgłaszają nieprawidłowości.

Komponenty przygotowuje się korzystając z języka TTCN-3, następnie translator
generuje kod w języku ogólnego przeznaczenia, który jest kompilowany powszechnie
dostępnymi narzędziami i łączony z biblioteką TTCN. Gotowe komponenty wykonywane
są jako samodzielne programy lub interpretowane w maszynie wirtualnej TTCN-3.

Interfejsem komunikacyjnym komponentów są porty. Warstwowa budowa systemu
pozwala oddzielić implementację od docelowego systemu. Dzięki wprowadzeniu
pośrednich adapterów możliwe jest łączenie portów poszczególnych komponentów ze
sobą (aby testować sam protokół) lub portami działających węzłów, co umożliwia
np. testowanie implementacji stosu TCP/IP systemu operacyjnego.

\subsubsection{Przykład}

Załóżmy, że tworzony przez nas komponent (np. urządzenie sprzętowe) ma za
zadanie natychmiast odsyłać (echo) odbierane dane. Chcemy zweryfikować tę
cechę. Dodatkowo, ponieważ w przypadku gdy błędnie pracujący komponent w ogóle
by nie odpowiedział, czekalibyśmy w nieskończoność na wynik, wprowadzamy limit
czasowy równy jednej sekundzie.

Poniżej prezentujemy przykład zaczerpnięty z materiałów szkoleniowych
TTCN \cite{ttcn-reference}.

W teście tym definiujemy komponent \code{MainComponent} wyposażony w jeden port
komunikacyjny oraz zegar, który użyty jest do implementacji limitu czasowego.

Nasz komponent, w celu uruchomienia, wymaga środowiska systemowego. TSI (Test
System Interface) zapewnia komunikację z testowanym komponentem, w terminologii
TTCN nazywanym SUT (System Under Test). Dzięki tym dwóm konceptom możemy
połączyć naszą "wirtualną" maszynę testującą z rzeczywistym komponentem, który
chcemy testować, korzystając z mechanizmów dostarczanych przez odpowiedni
adapter oraz system operacyjny.

\begin{textcode}
  type port PortType mixed { inout all; }
  
  type component MainComponent
  {
      port PortType p;
      timer T_WAIT := 1.0;
  }
  
  type component TSI_Type
  {
      port PortType tsiPort;
  }
\end{textcode}

Obie definicje łączymy tworząc przypadek testowy:

\begin{textcode}
  testcase TC_send() runs on MainComponent system TSI_Type
  {
      map(mtc:p, system:tsiPort);
  
      p.send(10);
      T_WAIT.start;
  
      alt
      {
          [] p.receive(10)
          {
              setverdict(pass);
          }
  
          [] p.receive /* any */
          {
              setverdict(fail);
          }
  
          [] T_WAIT.timeout
          {
              setverdict(fail);
          }
      }
  }
\end{textcode}

Powyższy kod stwierdza, że test został spełniony (\code{setverdict(pass)})
jeśli na porcie \code{p} otrzymamy, wcześniej wysłaną, wartość \code{10}.
Jeżeli otrzymamy cokolwiek innego test się nie powiedzie
(\code{setverdict(fail)}).  Tak samo postępujemy, jeśli przekroczymy wcześniej
określony limit czasowy.

Tak przygotowany test tłumaczy się na kod, np. w C++, który po skompilowaniu i
linkowaniu z bibliotekami TTCN jest gotowy do uruchomienia.

Zależnie od wybranych adapterów komunikacyjnych, możemy wybrać, gdzie
faktycznie zostaną wysłane dane. Mogą to być inne urządzenia, jeśli np.
testujemy implementację protokołu działającą na routerze sprzętowym lub inny
komponent TTCN, dzięki czemu uzyskujemy możliwość tworzenia prototypowych
implementacji protokołów. Możliwości są nieograniczone ponieważ możemy
dostarczyć własny adapter komunikacyjny.

\subsubsection{Podsumowanie}

TTCN jest dojrzałym i powszechnie używanym narzędziem. Jego możliwości pozwalają
w prosty sposób, dogłębnie testować komunikację na poziomie sekwencji
komunikatów. Uważamy, że rozwiązanie to wyczerpuje problematykę związaną z
mechanizmami pracy protokołu.

Obecnie narzędzie to nie pozwala na testowanie wydajności. Przygotowywane
rozwiązania są w fazie planowania. Dodatkowo, w celu zbadania wyłącznie
wydajności, nie jest potrzebne stosowanie niskopoziomowego TTCN. Można założyć,
że komunikacja między testowanymi komponentami przebiega według ustalonych
reguł, po czym obserwować jej efektywność.

\subsection{OMNeT++}
\label{omnet}

OMNeT++ to biblioteka i framework do tworzenia symulacji sieci. Użytkownik może korzystać z
szerokiej gamy modułów oraz tworzyć własne \cite{omnet-main}. Środowisko to
wspiera symulacje sterowane zdarzeniami przesyłanymi między występującymi w
realizowanej sieci komponentami. Istnieje szereg narzędzi zbudowanych na bazie
środowiska OMNeT++, które zostały stworzone z myślą o konkretnych rodzajach
sieci, jak np. OverSim będący symulatorem sieci peer2peer.

\begin{figure}
\begin{center}
\leavevmode
\includegraphics[width=0.8\textwidth]{intro-omnet-network}
\end{center}
\caption{Wizualizacja przebiegu symulacji w sieci złożonej z sześciu węzłów.
OMNeT++ umożliwia pełną instrumentację uruchomionego modelu. Na rysunku widać
(czerwona kropka) właśnie przesyłany komunikat.}
\label{fig:intro-omnet-network}
\end{figure}

Framework umożliwia pracę w IDE opartym na Eclipse i wspiera wiele pożądanych
funkcji jak np.~symulacje w czasie rzeczywistym czy integracja z bazą danych.
Tworzone symulacje można wykonywać jako samodzielne programy sterowane z linii
polecenia, aby zyskać na szybkości, lub pod kontrolą interfejsu graficznego
umożliwiającego dokładny wgląd w stan każdego elementu systemu.

Jest to program umożliwiający realizację i analizę prototypowych implementacji,
jak np.~algorytmów routingu. Nie został zaprojektowany z myślą o symulacji
złożonych systemów, takich jak pełna implementacja stosu sieciowego w systemie
operacyjnym. Tego typu realizacje są możliwe, ale działają niewydajnie.

\subsubsection{Przykład}

Pełna konfiguracja testu dla środowiska OMNeT++ jest zbyt złożona, żeby ją tu w
całości przytaczać. Prezentujemy tylko wybrane fragmenty, bazując na
materiałach szkoleniowych dostępnych w \cite{omnet-doc}.

Podstawowe moduły, tj. takie, których działanie programuje użytkownik,
definiowane są dyrektywą \code{simple}. Poniżej przykład komponentu o nazwie
\code{EtherMAC}. Zawiera on parametr \code{address}, którego wartość można
podać uruchamiając test lub zapisać w pliku konfiguracyjnym. Zdefiniowane są
także porty służące do komunikacji z innymi modułami. W tym wypadku warstwą LLC
oraz łącza danych.

\begin{textcode}
  simple EtherMAC {
      parameters:
          string address;
      gates:
          input phyIn;
          output phyOut;
          input llcIn;
          output llcOut;
  }
\end{textcode}

Komponenty typu \code{simple} można składać tworząc większe moduły, których
zadaniem jest organizacja podstawowych komponentów i definiowanie połączeń
między nimi.

Poniższy kod pokazuje jak z komponentów \code{EtherTrafficGen}, \code{EtherLLC}
oraz \code{EtherMAC} tworzony jest moduł \code{EtherStation}.

\begin{textcode}
  module EtherStation {
      parameters: ...
      gates: ...
          input in;
          output out;  
      submodules:
          app: EtherTrafficGen;
          llc: EtherLLC;
          mac: EtherMAC;
      connections:
          app.out --> llc.hlIn;
          app.in <-- llc.hlOut;
          llc.macIn <-- mac.llcOut;
          llc.macOout --> mac.llcIn;
          mac.phyIn <-- in;
          mac.phyOut --> out;
  }
\end{textcode}

Aby przykład był kompletny, należałoby jeszcze zdefiniować sieć i jej
topologię.  Powyższy moduł zawiera definicje dwóch portów (sekcja
\code{gates}), które mają posłużyć właśnie połączeniu z innymi komponentami
(np. modelującymi hub). Dodatkowo całość potrzebuje konfiguracji
uruchomieniowej. Graficzne środowisko ułatwia tworzenie tych brakujących elementów.

\begin{figure}
\begin{center}
\leavevmode
\includegraphics[width=0.8\textwidth]{intro-omnet-histogram}
\end{center}
\caption{Poza umożliwieniem uruchomienia zdefiniowania i uruchomienia
symulacji, pakiet OMNeT++ zawiera także narzędzia ułatwiające gromadzenie
danych statystycznych oraz graficzną analizę wyników. Na rysunku widać
przykładowy histogram uzyskany po wykonaniu testu.}
\label{fig:intro-omnet-histogram}
\end{figure}

\subsubsection{Podsumowanie}

OMNeT++ to rozbudowane środowisko umożliwiające tworzenie testów modelujących
złożone systemy. Pracę wspiera graficzny interfejs oraz framework
udostępniający szeroką gamę najczęściej potrzebnych funkcji.

Pewną wadą jest niska wydajność w sytuacji, gdy modeluje się systemy z dużą
liczbą komponentów intensywnie się komunikujących.

\subsection{Podsumowanie}

Przeprowadzenie testu w środowisku rozproszonym dostarcza nowego rodzaju
trudności związanych z koniecznością obsługi wielu urządzeń. Dostępne
rozwiązania najczęściej tworzone są z myślą o testowaniu w warunkach
symulacyjnych, gdzie całą sieć odtwarzamy na pojedynczym komputerze. Tego typu
testy są pomocne, jednak nie wyczerpują całego spektrum zastosowań.

Środowisko rzeczywistej sieci zachowuje się inaczej niż symulator. Zarówno ze
względu na cechy fizyczne, jak też realne rozproszenie maszyn, a co za tym
idzie inny sposób dostępu do nich. Trzeba też pamiętać, że aplikacje często
osiągają inne wyniki, kiedy pracują w realnej sieci i komunikują się między
sobą, a nie z symulatorem.

Nie dotarliśmy do programu, który ułatwiałby wykonanie testów w
rzeczywistych sieciach, gdzie problemy takie jak synchronizacja urządzeń i
zbieranie wyników powodują, że ręczne wykonywanie wszystkich czynności staje
się bardzo czasochłonne i uciążliwe, choć sam test jest w swojej naturze prosty.

W tabeli \fixref{tej poniżej} porównujemy naszym zdaniem najistotniejsze cechy
wspomnianych narzędzi. Jak widać Arete nie jest idealnym narzędzie do każdego
typu zastosowań. Nie jest to również narzędzie zdolne do samodzielnej pracy.
Uważamy jednak, że dobrze uzupełnia funkcjonalne braki istniejących rozwiązań i
razem z nimi pozwala stworzyć praktyczne i wygodne środowisko testowe.

\begin{small}
\begin{center}
   \begin{tabular}{ l || C{1.1cm} | C{1.1cm} | C{1.1cm} | C{1.1cm}   }
      \hline
      & \small{\parbox[top][2.4em][c]{1.1cm}{\centering{ASN.1+\\ECN}}} & \small{TTCN} & \small{OMNeT} & \small{Arete} \\
      \hline
      Powtarzanie eksperymentów & $+$ & $+$ & $+$ & $+$ \\
      \hline
      Deterministyczne wyniki & $+$ & $+$ & $+$ & $-$ \\
      \hline
      Weryfikacja wyników & $+$ & $+$ & $-$ & $-$ \\
      \hline
      Uwzględnienie wpływu środowiska & $-$ & $-$ & $-$ & $+$ \\
      \hline
      Wykorzystanie rzeczywistych urządzeń & $-$ & $-$ & $-$ & $+$ \\
      \hline
      Testy wymienianych PDU & $+$ & $+$ & $+$ & $-$ \\
      \hline
      Testy sekwencji komunikatów & $-/+$ & $+$ & $+$ & $-/+$ \\
      \hline
      Testy wydajnościowe & $-$ & $+$ & $-$ & $+$ \\
      \hline
      Brak wpływu na wydajność & $-$ & $-$ & $-$ & $+$ \\
      \hline
      Możliwość rozwijania narzędzia & $-$ & $-/+$ & $+$ & $+$ \\
      \hline
      Dostępne darmowo & $-/+$ & $-$ & $-/+$ & $+$ \\
      \hline
      Łatwość nauki & $-$ &  $+$ & $+$ & $+$ \\
      \hline

  \end{tabular}
\end{center}
\end{small}


\section{Instalacja i uruchomienie Arete}

Instalacja narzędzia Arete jest bardzo prosta dzięki wykorzystaniu wbudowanej w
język Python biblioteki \code{distutils} \cite{distutils}. Polega ona na
wykonaniu poniższej komendy z uprawnieniami administratora.

\code{\# python setup.py install}

Do poprawnego działania wymagane jest również zainstalowanie następujących
zależności:

\begin{itemize}
\item{argparse \cite{argparse} - parsowanie argumentów,}
\item{elixir \cite{elixir} - obsługa bazy danych,}
\item{paramiko \cite{paramiko} - obsługa połączeń SSH}
\end{itemize}

Kolejnym krokiem jest uruchomienie demonów Arete Slave na komputerach biorących
udział w teście. Jeśli uruchamiane przez nas testy będą wymagać uprawnień
administratora musimy wykonać poniższą komendę z takimi uprawnieniami.

\code{\# arete-slave -v}

Ponieważ na każdym z urządzeń będzie działać tylko jeden demon, możemy
skorzystać z domyślnych ustawień. W przeciwnym wypadku wymagane jest użycie
dodatkowych parametrów opisanych w rozdziale \ref{arete-slave-run}, aby
zróżnicować porty i nazwy plików bazy danych. Użycie parametru \code{-v}
spowoduje wypisywanie loga na standardowe wyjście, co ułatwi nam obserwację
przebiegu testu. 

Następnie tworzymy konfigurację testu. Po szczegółowy opis tej części
testowania przy pomocy Arete odsyłamy do rozdziału \ref{arete-master-config}.
W omówionych w dalszej części tego rozdziału przykładach krok po kroku omówimy
tworzone modele i plany testów. Tymczasem na potrzeby tej instrukcji założymy,
że stworzyliśmy już wspomniane elementy w pliku \code{configuration}.

Niezależnie od tego jaki test chcemy wykonać, potrzebujemy konfiguracji
laboratorium. Zostało to szerzej opisane w rozdziale
\ref{arete-master-config-lab}. Przykładowy plik laboratorium przedstawiono
poniżej. 

\begin{pythoncode}
  # laboratory:
  create_laboratory('laboratory')

  add_device('marvin',
      connection='tcp',
      ip='192.168.0.2',
      port='4567',
      frontend='arete_slave')

  add_device('defteros',
      connection='tcp',
      ip='192.168.0.3',
      port='4567',
      frontend='arete_slave')
\end{pythoncode}

Kolejnym krokiem jest stworzenie odwzorowania między modelem a labolatorium.
Odwzorowania były omówione w rozdziale \ref{arete-master-config-mapping}. 
Jeśli chcielibyśmy zawrzeć go w pliku konfiguracyjnym, wyglądałoby to
następująco.

\begin{pythoncode}
  create_mapping('configuration-to-laboratory')

  bind('host1', 'marvin')
  bind('host2', 'defteros')
\end{pythoncode}

Alternatywnie, odwzorowanie możemy podać w linii poleceń programu Arete Master,
korzystając z argumentu \code{--map}, jak przedstawiono w przykładzie poniżej.
Test uruchamiamy podając wszystkie pliki konfiguracyjne po argumencie \code{-c}.
Opis wszystkiech parametrów znajduje się w rozdziale \ref{arete-master-run}.

\code{\$ arete -c configuration laboratory --map host1:marvin host2:defteros}

\section{Przykład: Aplikacja klient-serwer}
\label{example-client-server}

Pierwszym przykładem który omówimy jest prosty scenariusz, z którym często mamy
do czynienia w czasie tworzenia oprogramowania typu klient-serwer. W naszym
przypadku będzie to program umożliwiający transfer plików, gdzie zarówno serwer
jak i klient będą sterowane z linii poleceń. W teście będziemy chcieli sprawdzić
czy transfer przebiegł poprawnie, tj. czy zawartość przesłanego pliku jest
identyczna i czy zgadza się jego nazwa.

W przykładzie wykorzystaliśmy proste aplikacje napisane w języku Python, których
kod zamieszczamy poniżej. Klient łączy się z serwerem i korzystając z protokołu
TCP przesyła nazwę i zawartość wskazanego pliku. Serwer nasłuchuje na
przychodzące połączenia i odbiera nazwę oraz zawartość transmitowanego pliku, a
następnie zapisuje go w lokalnym systemie plików.

\begin{pythoncode}
  # Client.py:
  import sys
  import socket

  if __name__ == "__main__":
      if len(sys.argv) != 5:
	  print >>sys.stderr, \
	      "Usage: {0} <ip> <port> <file> <destname>".format(sys.argv[0])
	  sys.exit(1)

      ip = sys.argv[1]
      port = int(sys.argv[2])
      filename = sys.argv[3]
      destname = sys.argv[4]

      sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
      sock.connect((ip, port))

      sock.send(destname+'\n')

      with open(filename, 'r') as file:
          sock.sendall(file.read())

      sock.close()

      print 'transfer done'

\end{pythoncode}

\begin{pythoncode}
  # Server.py:
  import sys
  import SocketServer

  class FileTransferHandler(SocketServer.BaseRequestHandler):
      def handle(self):
          input  = self.request.makefile('r', 0)
          filename = input.readline().strip()

          print 'received', filename

          with open(filename, 'w') as file:
	      file.write(input.read())
  
          self.request.close()

  if __name__ == "__main__":
      if len(sys.argv) != 3:
          print >>sys.stderr, "Usage: {0} <ip> <port>".format(sys.argv[0])
          sys.exit(1)

      ip = sys.argv[1]
      port = int(sys.argv[2])

      server = SocketServer.TCPServer((ip, port), FileTransferHandler)
      server.serve_forever()

\end{pythoncode}

\subsection{Przebieg}

\begin{figure}[htb]
\begin{center}
\leavevmode
\includegraphics[width=0.6\textwidth]{example-01-sequence}
\end{center}
\caption{Schemat przebiegu testu aplikacji klient-serwer.}
\label{fig:example-01-sequence}
\end{figure}

Zacznijmy od prześledzenia zobrazowany na rysunku \ref{fig:example-01-sequence}
przebieg testu. Zaczynamy od wystartowania serwera (\code{1}) na urządzeniu
\code{Server}.  Następnie na drugim urządzeniu uruchamiany jest klient
(\code{2}), który łączy się z serwerem i przesyła do niego wskazany plik. Po
zakończeniu transferu klient kończy działanie i uruchamiane jest obliczenie sumy
kontrolnej (\code{3}) oraz wysyłane jest powiadomienie (\code{4}) do modułu
Arete Master. Ten wysyła wyzwalacz do Arete Slave na urządzeniu \code{Server},
który odbiera go (\code{5}) i kończy pracę serwera. Na koniec na urządzeniu
\code{Server} sprawdzana jest nazwa pliku (\code{6}) oraz suma kontrolna
(\code{7}), a następnie przesłany plik jest usuwany (\code{8}).

\subsection{Konfiguracja}

Poniżej omówiliśmy szczegółowo konfigurację testu w ramach którego zostaną
wykonane opisane przed chwilą czynności. Zawiera ona jedynie model i plan testu.
Zakładamy, że użytkownik zapoznał się z rozdziałami \ref{arete-master-config}
oraz \ref{examples-install-run} omawiającymi konfigurację oraz uruchomienie
testów za pomocą Arete.

\begin{pythoncode}
  # examples/client-server/configuration:
  create_model('client-server')

  add_host('client')
  add_host('server')
\end{pythoncode}

Na początku tworzymy model o nazwie \code{client-server}. Ponieważ do
przeprowadzenia testu potrzebujemy dwóch urządzeń - klienta i serwer, dodajemy
je do stworzonego modelu. 

\begin{pythoncode}
  create_schedule('client-server')

  test_end_policy('complete')
  create_trigger('kill-server', 1)
\end{pythoncode}

Tworzymy również plan testu \code{client-server}, aby móc określić jakie komendy
będę wykonywane na urządzeniach, a następnie konfigurujemy globalne ustawienia
testu. Ponieważ nie wiemy jak długo potrwa test, ustawiamy politykę zakończenia
testu na \code{complete}. Spowoduje to zakończenie testu dopiero w momencie, gdy
zakończy się on na wszystkich urządzeniach biorących w nim udział. Zwróćmy
uwagę, że jednym z urządzeń jest serwer, który z założenia nie kończy swojego
działania. Z tego powodu tworzymy wyzwalacz o nazwie \code{kill-server}, mający
za zadanie zakończyć działanie serwera, gdy określona ilość urządzeń (w naszym
przypadku jeden klient), powiadomi o zakończeniu testu. Wartość tę podajemy jako
drugi parametr komendy \code{create\_trigger}.

\begin{pythoncode}
  add_resource(File('clientdist', 'Client.py', chmod='+x'))
  add_resource(File('serverdist', 'Server.py', chmod='+x'))
  add_resource(File('testfile', 'datafile.txt'))
\end{pythoncode}

Kolejnym etapem jest dodanie zasobów biorących udział w teście. Będą to
oczywiście programy \code{Client.py} oraz \code{Server.py}. Aby zapewnić im
odpowiednie prawa po przesłaniu na zdalne urządzenia, koszystamy z parametru
\code{chmod}. Jako trzeci dodajemy plik który zostanie przesłany między
urządzeniami.

\begin{pythoncode}
  append_schedule('client', [
      ('client', at(1), \
          shell('./@{clientdist.name} @{server.ip} 6666 \
	  @{testfile.name} dest_path', \
	  use_resources=['clientdist', 'testfile'], check_executable=False)),
      ('md5sum', after('client'), shell('md5sum @{testfile.name}')),
      ('notify', after('md5sum'), notify('kill-server'))
  ])
\end{pythoncode}

Najważniejszą częścią konfiguracji jest określenie szczegółowego planu
wykonywania komend na urządzeniach. W przypadku klienta uruchamiamy program
\code{Client.py} z odpowiednimi parametrami, tj. adresem i portem serwera, nazwą
pliku który zostanie przesłany oraz docelową nazwą pliku. W parametrze
\code{use\_resources} podajemy nazwy stworzonych wcześniej zasobów. Parametr
\code{check\_executable=False} zapobiega sprawdzeniu czy komenda którą chcemy
wykonać jest wykonywalna, ponieważ sami zadbaliśmy o to nadając plikom
odpowiednie prawa podczas ich tworzenia. Zwróćmy uwagę, że komenda \code{client}
uruchamiana jest z sekundowym opóźnieniem (\code{at(1)}), aby pozostawić czas na
uruchomienie serwera.

Następnie dodajemy dwa zadania, które będą wykonywane gdy program klienta
zakończy działanie (funkcja \code{after()}). Pierwsze z nich to komenda
sprawdzająca sumę kontrolną przesyłanego pliku korzystając z polecenia
\code{md5sum}. Drugie powoduje powiadomienie Arete Master o zakończeniu
działania. Ponieważ wyzwalacz o nazwie \code{kill-server} czeka tylko na
jedno powiadomienie, Arete Slave otrzyma dzięki niemu sygnał do wykonania
komendy kończącej działanie serwera.

\begin{pythoncode}
  append_schedule('server', [
      ('server', at(0), \
          shell('./@{serverdist.name} 0.0.0.0 6666', \
          use_resources=['serverdist'], check_executable=False)),
      ('trigger', trigger('kill-server'), shell('kill @{server.pid}')),
      ('ls', after('server'), shell('ls dest_path')),
      ('md5sum', after('ls'), shell('md5sum dest_path')),
      ('rm', after('md5sum'), shell('rm -f dest_path'))
  ])
\end{pythoncode}

W przypadku serwera na początku uruchamiany jest program \code{Server.py} z
odpowiednimi parametrami. Podobnie jak w kliencie przesyłane są wymagane zasoby
oraz flaga \code{check\_executable} ustawiana jest na \code{False}. Następnie
tworzona jest komenda kończąca działanie komendy \code{server}, która zostanie
uruchomiona po otrzymaniu sygnału o nazwie \code{kill-server} od modułu Arete
Master. Pozwoli to na uruchomienie dalszych komend, sprawdzających nazwę oraz
sumę kontrolną otrzymanego od klienta pliku, usunięcie go oraz zakończenie
testu.

\subsection{Wyniki}

Po zakończeniu testu Arete Master odbiera wyniki od obu modułów Slave
uczestniczących w teście i zapisuje je do swojej bazy danych. W tym przykładzie
wyglądają one następująco.

\begin{description}
\item[]
  node: client
  \begin{description}
  \item[start time] 2010-11-14 21:46:46.171340
  \item[duration] 1.442621
  \item[]
    command: 'client'
    \begin{description}
      \item[output] transfer done
      \item[start time] 2010-11-14 21:46:47.171994
      \item[duration] 0.049891
      \item[return code] 0
    \end{description}
  \item[]
    command: 'md5sum'
    \begin{description}
      \item[output] 015f88fc887a556bf7eab90ec32c8c46  testfile
      \item[start time] 2010-11-14 21:46:47.371130
      \item[duration] 0.057670
      \item[return code] 0
    \end{description}
  \end{description}
\end{description}

\begin{description}
\item[]
  node: server
  \begin{description}
  \item[start time] 2010-11-14 21:46:46.172080
  \item[duration] 1.802907
  \item[]
    command: 'server'
    \begin{description}
      \item[output] 
      \item[start time] 2010-11-14 21:46:46.179522
      \item[duration] 1.532876
      \item[return code] -15
    \end{description}
  \item[]
    command: 'ls'
    \begin{description}
      \item[output] dest\_path
      \item[start time] 2010-11-14 21:46:47.733533
      \item[duration] 0.056964
      \item[return code] 0
    \end{description}
  \item[]
    command: 'md5sum'
    \begin{description}
      \item[output] 015f88fc887a556bf7eab90ec32c8c46  dest\_path
      \item[start time] 2010-11-14 21:46:47.823826
      \item[duration] 0.049728
      \item[return code] 0
    \end{description}
  \end{description}
\end{description}

Jak widzimy w bazie danych oprócz informacji dotyczących całego testu, takich
jak czas jego rozpoczęcia i długość trwania na każdym z komputerów, mamy do
dyspozycji szczegółowe dane na temat każdej z wykonanych komend, tj. wyjście,
zwrócony kod wyjścia, czas rozpoczęcia oraz długość trwania.

Choć interpretacja wyników nie jest celem naszej pracy, na potrzeby opisanego
przykładu możemy zaobserwować, że nazwa pliku otrzymana z komendy ls na serwerze
jest poprawna, a sumy kontrolne na obu urządzeniach są zgodne. Możemy zatem
wywnioskować, że stworzone przez nas implementacje programów klient-serwer są
poprawne.

\section{Przykład: Wpływ transmisji TCP na pracę DCCP}
\label{example-dccp}

Drugi przykład dotyczy pomiaru szybkości transferu danych przy użyciu protokołu
DCCP oraz wpływu innych transmisji na tę szybkość. Sposób pomiaru jest prosty.
Wykorzystujemy program \code{iperf}, który umożliwia uruchomienie serwera i
klienta wybranego protokołu. Klient transmituje do serwera strumień losowych
danych korzystając ze wskazanego protokołu transportowego i zapamiętuje uzyskaną
szybkość transmisji. Dodatkowo, przy użyciu reguł \code{iptables} mierzy się
ilość pakietów i bajtów całego ruchu sieciowego.

Stworzyliśmy kilka różnych testów badających m.in.: samodzielną pracę DCCP,
wpływ transmisji TCP i UDP na pracę DCCP, porównanie DCCP z TCP i UDP, itd.
Różniły się one kolejnością i momentami, w których na uczestniczących w teście
urządzeniach należało uruchomić lub zakończyć \code{iperf}. W tym przykładzie
zaprezentujemy test przedstawiający wpływ transmisji TCP na pracę DCCP. 

\subsection{Przebieg}

\begin{figure}[htb]
\begin{center}
\leavevmode
\includegraphics[width=0.8\textwidth]{example-03-sequence}
\end{center}
\caption{Schemat przebiegu testu badającego wpływ transmisji TCP na pracę
protokołu DCCP.}
\label{fig:example-03-sequence}
\end{figure}

Przebieg testu przestawiliśmy na rysunku \ref{fig:example-03-sequence}. Na
początku na urządzeniu \code{Server} uruchamiane są dwa serwery \code{iperf} -
jeden dla protokołu TCP, drugi korzystający z DCCP. Następnie na obu
urządzeniach rozpoczynamy wykonywanie komendy \code{iptables} zwracającej
statystyki ruchu sieciowego. Komenda ta będzie wykonywana co sekundę aż do
zakończenia testu. Z sekundowym opóźnieniem uruchamiamy na urządzeniu
\code{Client} klienta \code{iperf} który rozpoczyna komunikację z odpowiednim
serwerem z wykorzystaniem protokołu DCCP. W 10 sekundzie rozpoczynamy transmisję
TCP uruchamiając kolejnego klienta \code{iperf}. Test kończy się po 20
sekundach.

\subsection{Konfiguracja}

\begin{pythoncode}
  class IPTablesCounters(HostDriverPlugin):
      def process(self, cmd, host, attributes):
          if 'iptables_counters' not in attributes:
              return 

          protocols = host.model['iptables_counters']

          cmd.add_setup('iptables -F')
          for proto in protocols:
              cmd.add_setup('iptables -I INPUT -p {0}'.format(proto))
              cmd.add_setup('iptables -I OUTPUT -p {0}'.format(proto))

          cmd.add_cleanup('iptables -F')

          attributes.remove('iptables_counters')
\end{pythoncode}

Zaczynamy od stworzenia sterownika parametrów (\code{HostDriverPlugin} - opisany
szerzej w rozdziale \ref{arete-master-drivers}), który dla każdego z urządzeń doda
komendy konfiguracyjne i czyszczące tworzące odpowiednie wpisy w \code{iptables}
dla podanych protokołów.

\begin{pythoncode}
  create_model('dccp_flow')

  add_host('client', iptables_counters=['33', 'tcp', 'udp'])
  add_host('server', iptables_counters=['33', 'tcp', 'udp'])
\end{pythoncode}

Następnie tworzymy model o nazwie \code{dccp\_flow} i podobnie jak w poprzednim
przykładzie dodajemy dwa urządzenia - klienta i serwer. W parametrze
\code{iptables\_counters} podajemy listę protokołów dla wcześniej stworzonego
sterownika parametrów. Liczba \code{33} odpowiada protokołowi DCCP.

\begin{pythoncode}
  create_schedule('dccp_flow')

  test_end_policy('duration 20', setup_phase_delay=2.0)
\end{pythoncode}

Tworzymy także plan testu o nazwie \code{dccp\_flow}. Ponieważ ważne jest, żeby
w czasie testu program nie przesyłał żadnych nadmiarowych danych, które
wpłynęłyby na uzyskane wyniki, ustawiamy czas trwania testu na stałą wartość
\code{20} sekund. Spowoduje to rozłączenie się Arete Master po przesłaniu testu
i ponowne połączenie po zakończeniu testu. Ponieważ test wymaga wykonania komend
konfiguracyjnych ustawiamy opóźnienie testu na \code{2.0} korzystając z
parametru \code{setup\_phase\_delay}.

\begin{pythoncode}
  dccp = ClientServer('dccp',
      server_command='iperf -s -p 7999 -d',
      client_command='iperf -c @{server.ip} -p 7999 -d -t 18')

  tcp = ClientServer('tcp',
      server_command='iperf -s -p 7998',
      client_command='iperf -c @{server.ip} -p 7998 -t 9')
\end{pythoncode}

Korzystając z gotowej klasy \code{ClientServer} z modułu \code{Utils} tworzymy
komendy uruchamiające \code{iperf} w trybie klienta (\code{-c}) oraz serwera
(\code{-s}) dla protokołów DCCP (opcja \code{-d}) oraz TCP (domyślnie).

\begin{pythoncode}
  append_schedule('server', dccp.server(start=0, end=20))
  append_schedule('client', dccp.client(start=1, end=None, server='server'))

  append_schedule('server', tcp.server(start=0, end=20))
  append_schedule('client', tcp.client(start=10, end=None, server='server'))

  append_schedule('server', [('counters', every(1), \
      shell('iptables -L -v -n -Z -x'))])
  append_schedule('client', [('counters', every(1), \
      shell('iptables -L -v -n -Z -x'))])
\end{pythoncode}

Na koniec dodajemy do planu testu stworzone wcześniej komendy. Na urządzeniu
\code{server} dodajemy serwery DCCP i TCP, które działać będą przez cały czas
trwania testu. Na urządzeniu \code{client} w \code{1} sekundzie uruchamiamy
klienta DCCP, a w \code{10} sekundzie klienta TCP. Na obu urządzeniach co
sekundę zapisujemy wynik komendy wypisującej ilość przesłanych pakietów i
bajtów.

\subsection{Wyniki}

Korzystając z otrzymanych w tym teście wyników w postaci statystyk zebranych
przez cosekundowe wywołania komendy \code{iptables} byliśmy w stanie sporządzić
wykres przedstawiony na rysunku \fixref{rysunek}.

\FIXME{Rydzyn zrobi wykres ładny.}

\FIXME{Wnioski z tego co otrzymaliśmy, czyli interpretacja tego wykresu.}

\section{Przykład: Dystrybucja pliku w sieci BitTorrent}
\label{example-torrent}

Trzeci, ostatni przykład, który przedstawimy, to ćwiczenie laboratoryjne z
Systemów Peer-to-Peer. Test polega na pomiarze czasu dystrybucji pliku w sieci
BitTorrent. Klienci mają rozpocząć pobieranie w tym samym momencie, a test należy
zakończyć kiedy wszyscy będą posiadać pełny plik. Interesuje nas, ile każdy
klient wysłał danych i ile trwała pełna dystrybucja pliku.

Przykład ten można wykorzystać do stworzenia testów na różnych topologiach,
poniżej omówimy sytuację z dowolną ilością urządzeń znajdujących się w tej samej
podsieci. Oprócz urządzeń typu peer\footnote{\emph{ang. pośrednik} - użytkownik,
który w danym momencie pobiera lub udostępnia dany plik.} wykorzystamy dwa
osobne urządzenia, które będą pełnić rolę trackera\footnote{\emph{ang.
tropiciel} - serwer przekazujący informacje użytkownikach pobierających dany
plik.} i seeda\footnote{\emph{ang. obsiewacz} - użytkownik, który posiada
kompletny plik i udostępnia go innym osobom.}.

Do stworzenia danych które będą przesyłane w czasie testu oraz pliku
torrent\footnote{Metaplik zawierający niezbędne informacje do rozpoczęcia
pobierania pliku, takich jak zawartość archiwum i adres trackera czy sumy
kontrolne plików.} można wykorzystać stworzony przez nas skrypt
\code{create\_torrent.sh} znajdujący się w katalogu z przykładem. Pobiera on
trzy argumenty - adres i port, na których docelowo będzie uruchomiony tracker
oraz rozmiar tworzonego pliku danych.

\subsection{Przebieg}

\begin{figure}[htb]
\begin{center}
\leavevmode
\includegraphics[width=0.8\textwidth]{example-02-sequence}
\end{center}
\caption{Schemat przebiegu testu z wykorzystaniem sieci BitTorrent.}
\label{fig:example-02-sequence}
\end{figure}

Zacznijmy od opisu przebiegu testu, który przedstawiono na rysunku
\ref{fig:example-02-sequence}. Na urządzeniu \code{Tracker} uruchamiamy tracker
BitTorrent, a następnie na urządzeniu \code{Seed} rozpoczynamy udostępnianie
pliku przez jednego z klientów (\emph{ang. seeding}). Z parosekundowym
opóźnieniem, równocześnie uruchamiamy na urządzeniach \code{Peer} klientów,
którzy pobierają plik. Gdy klient kończy pobieranie wysyła powiadomienie do
modułu Arete Master. W momencie gdy ten otrzyma powiadomienia od wszystkich
klientów działających na urządzeniach \code{Peer} wysyła wyzwalacze do Arete
Slave na wszystkich urządzeniach. Powoduje to zakończenie pracy trackera oraz
wszystkich klientów i zakończenie testu.

\subsection{Konfiguracja}

\begin{pythoncode}
  # examples/torrent/model_x_peers
  create_model('torrent')

  tracker = add_host('tracker')
  seed = add_host('seed')

  peers = []
  for i in range(10):
      peers.append(add_host('peer{0}'.format(i)))
\end{pythoncode}

Rozpoczynamy od stworzenia modelu o nazwie \code{torrent}. Dodajemy do niego dwa
urządzenia, które będą pełnić rolę trackera i seeda, a następnie określoną ilość
(w tym wypadku 10) pozostałych urządzeń które będę brały udział w teście.

\begin{pythoncode}
  # examples/torrent/schedule_torrent
  create_schedule('torrent')
    
  test_end_policy('complete')
  create_trigger('stop-torrent', len(peers))
\end{pythoncode}

Następnie przechodzimy do stworzenia planu testu \code{torrent}, określając jego
politykę zakończenia na \code{complete}. Tworzymy również wyzwalacz o nazwie
\code{stop-torrent}, ustawiając jego wartość na ilość urządzeń typu \code{peer}
biorących udział w teście.

\begin{pythoncode}
  torrent = add_resource(File('torrent', 'big-data-file.torrent'))
  data = add_resource(File('torrent-data', 'big-data-file'))
  trackcfg = add_resource(File('trackcfg', 'xbt_tracker.conf'))
\end{pythoncode}

Kolejnym etapem jest stworzenie zasobów. Dodajemy stworzony wcześniej plik z
danymi oraz plik torrent. Dodatkowo przesyłamy plik konfiguracyjny dla trackera
XBT.

\begin{pythoncode}
  tracker_schedule = [
      ('tracker', at(0), shell('xbt_tracker --conf_file @{trackcfg.name}', \
          use_resources=[trackcfg])),
      ('stop-torrent', trigger('stop-torrent'), shell('kill @{tracker.pid}'))
  ]
\end{pythoncode}

Szczegółowy plan testu rozpoczynamy od urządzenia \code{Tracker}. Na początku testu
uruchamiamy program \code{xbt\_tracker} podając jako argument przesłany z
wykorzystaniem parametru \code{use\_resources}, stworzony wcześniej plik
konfiguracyjny. Na koniec dodajemy komendę kończącą działanie trackera, która
zostanie uruchomiona po otrzymaniu sygnału o nazwie \code{stop-torrent} od
modułu Arete Master.

\begin{pythoncode}
  seed_schedule = [ 
      ('ctorrent', at(1), shell('ctorrent "@{torrent.name}"', \
          use_resources=[torrent, data])),
      ('stop', trigger('stop-torrent'), shell('kill -9 @{ctorrent.pid}'))
  ]
\end{pythoncode}

Następnie tworzymy plan testu dla urządzenia udostępniającego. Dodajemy komendę
uruchamiającą klienta \code{ctorrent} oraz kończącą go w odpowiedzi na wyzwalacz
\code{stop-torrent}. W parametrze \code{use\_resources} podajemy zarówno plik
torrent jak i plik z danymi które mają być udostępniane.

\begin{pythoncode}
  peer_schedule = [
      ('ctorrent', at(2), \
          shell('ctorrent "@{torrent.name}" -X @{poke stop-torrent}', \
          use_resources=[torrent])),
      ('poke', poke('stop-torrent'), notify('stop-torrent')),
      ('stop', trigger('stop-torrent'), shell('kill -9 @{ctorrent.pid}'))
  ]
\end{pythoncode}

Podobnie jak w przypadku urządzenia \code{Seed}, plan testu na pozostałych
urządzeniach rozpoczyna się od uruchomienia klienta \code{ctorrent}. Różnica
polega na tym, że jest on uruchamiany dopiero w 2 sekundzie testu oraz nie
posiada pliku danych, gdyż ten nie jest przesyłany w parametrze
\code{use\_resources}.

Ponieważ chcemy aby klient działał dalej i udostępniał dane pozostałym klientom
po zakończeniu pobierania wykorzystujemy udostępniany przez klienta
\code{ctorrent} argument \code{-X}. Podana po nim komenda \code{\@\{poke
stop-torrent\}} uruchamia program \code{arete-poker} z odpowiednimi argumentami,
który łączy się z Arete Slave i uruchamia polecenie \code{poke}, które z kolei
wysyła powiadomienie do modułu Arete Master.

Tak jak w przypadku pozostałych planów dodajemy wyzwalacz \code{stop-torrent}
kończący działanie klienta.

\begin{pythoncode}
  append_schedule('tracker', tracker_schedule)
  append_schedule('seed', seed_schedule)

  for host in peers:
      append_schedule(host, peer_schedule)
\end{pythoncode}

Na koniec dodajemy odpowiednie plany do stworzonych w modelu urządzeń.

\subsection{Wyniki}

\FIXME{Też jakiś wykres można by zrobić.}

\section{Podsumowanie}

\FIXME{Napisać jak we wszystkich 3 przykładach sprawdziliśmy, że Arete działa
świetnie, jest łatwy w obsłudze, efektywny i nadaje się do różnego rodzaju testów.}

\end{document}
