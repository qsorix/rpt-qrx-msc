\documentclass[00-praca-magisterska.tex]{subfiles}
\begin{document}

\chapter{Przykłady}

\section{Instalacja}

\FIXME{Opis instalacji Arete.}

\section{Przykład: Klient-serwer}

Pierwszym przykładem który omówimy jest prosty scenariusz, z którym często mamy
do czynienia w czasie tworzenia oprogramowania typu klient-serwer. W naszym
przypadku będzie to program umożliwiający transfer plików, gdzie zarówno serwer
jak i klient będą sterowane z linii poleceń. W teście będziemy chcieli sprawdzić
czy transfer przebiegł poprawnie, tj. czy zawartość przesłanego pliku jest
identyczna i czy zgadza się jego nazwa.

W przykładzie wykorzystaliśmy proste aplikacje napisane w języku Python, których
kod zamieszczamy poniżej. Klient łączy się z serwerem i korzystając z protokołu
TCP przesyła nazwę i zawartość wskazanego pliku. Serwer nasłuchuje na
przychodzące połączenia i odbiera nazwę oraz zawartość transmitowanego pliku, a
następnie zapisuje go w lokalnym systemie plików.

\begin{pythoncode}
  # Client.py:
  import sys
  import socket

  if __name__ == "__main__":
      if len(sys.argv) != 5:
	  print >>sys.stderr, \
	      "Usage: {0} <ip> <port> <file> <destname>".format(sys.argv[0])
	  sys.exit(1)

      ip = sys.argv[1]
      port = int(sys.argv[2])
      filename = sys.argv[3]
      destname = sys.argv[4]

      sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
      sock.connect((ip, port))

      sock.send(destname+'\n')

      with open(filename, 'r') as file:
          sock.sendall(file.read())

      sock.close()

      print 'transfer done'

\end{pythoncode}

\begin{pythoncode}
  # Server.py:
  import sys
  import SocketServer

  class FileTransferHandler(SocketServer.BaseRequestHandler):
      def handle(self):
          input  = self.request.makefile('r', 0)
          filename = input.readline().strip()

          print 'received', filename

          with open(filename, 'w') as file:
	      file.write(input.read())
  
          self.request.close()

  if __name__ == "__main__":
      if len(sys.argv) != 3:
          print >>sys.stderr, "Usage: {0} <ip> <port>".format(sys.argv[0])
          sys.exit(1)

      ip = sys.argv[1]
      port = int(sys.argv[2])

      server = SocketServer.TCPServer((ip, port), FileTransferHandler)
      server.serve_forever()

\end{pythoncode}

\subsection{Konfiguracja}

Poniżej omówiliśmy szczegółowo konfigurację testu. Zawiera ona jedynie model i
plan testu, natomiast laboratorium i odzworowanie między modelem a laboratorium
zostaną przedstawione później. Zakładamy, że użytkownik zapoznał się z działem
\fixref{Konfiguracja}.

\begin{pythoncode}
  create_model('client-server')

  add_host('client')
  add_host('server')
\end{pythoncode}

Na początku tworzymy model o nazwie \code{client-server}. Ponieważ do
przeprowadzenia testu potrzebujemy dwóch urządzeń - klienta i serwer, dodajemy
je do stworzonego modelu. 

\begin{pythoncode}
  create_schedule('client-server')

  test_end_policy('complete', setup_phase_delay=0.0)
  create_trigger('kill-server', 1)
\end{pythoncode}

Tworzymy również plan testu \code{client-server}, aby móc określić jakie
komendy będę wykonywane na urządzeniach, a następnie konfigurujemy globalne
ustawienia testu. Ponieważ ciężko przewidzieć nam jak długo potrwa test,
ustawiamy politykę zakończenia testu na \code{complete}. Spowoduje to
zakończenie testu dopiero w momencie, gdy zakończy się on na wszystkich
urządzeniach biorących w nim udział. Zwróćmy uwagę, że jednym z urządzeń jest
serwer, który z założenia nie kończy swojego działania. Z tego powodu tworzymy
\fixme{trigger}, mający za zadanie zakończyć działanie serwera, gdy określona
ilość urządzeń (w naszym przypadku jeden klient), powiadomi o zakończeniu
testu. Wartość tę podajemy jako drugi parametr komendy \code{create\_trigger}.
W komendzie \code{test\_end\_policy} jak parametr \code{setup\_phase\_delay}
podajemy czas potrzebny na uruchomienie komend konfiguracyjnych. W naszym
przypadku czas ten wynosi \code{0.0} ponieważ nie jest wymagana dodatkowa
konfiguracja.

\begin{pythoncode}
  add_resource(File('clientdist', 'Client.py', chmod='+x'))
  add_resource(File('serverdist', 'Server.py', chmod='+x'))
  add_resource(File('testfile', 'datafile.txt'))
\end{pythoncode}

Kolejnym etapem jest dodanie zasobów biorących udział w teście. Będą to
oczywiście programy \code{Client.py} oraz \code{Server.py}. Aby zapewnić im
odpowiednie prawa po przesłaniu na zdalne urządzenia, koszystamy z parametru
\code{chmod}. Jako trzeci dodajemy plik który zostanie przesłany między
urządzeniami.

\begin{pythoncode}
  append_schedule('client', [
      ('client', at(1), \
          shell('./@{clientdist.path} @{server.ip} 6666 @{testfile.path} dest_path', \
	  use_resources=['clientdist', 'testfile'], check_executable=False)),
      ('md5sum', after('client'), shell('md5sum @{testfile.path}')),
      ('notify', after('md5sum'), notify('kill-server'))
  ])
\end{pythoncode}

Najważniejszą częścią konfiguracji jest określenie szczegółowego planu
wykonywania komend na urządzeniach. W przypadku klienta uruchamiamy program
\code{Client.py} z odpowiednimi parametrami, tj. adresem i portem serwera, nazwą
pliku który zostanie przesłany oraz docelową nazwą pliku. W parametrze
\code{use\_resources} podajemy nazwy stworzonych wcześniej zasobów. Parametr
\code{check\_executable=False} zapobiega sprawdzeniu czy komenda którą chcemy
wykonać jest wykonywalna, ponieważ sami zadbaliśmy o to nadając plikom
odpowiednie prawa podczas ich tworzenia. Zwróćmy uwagę, że komenda \code{client}
uruchamiana jest z sekundowym opóźnieniem (\code{at(1)}), aby pozostawić czas na
uruchomienie serwera.

Następnie dodajemy dwa zadania, które będą wykonywane gdy program klienta
zakończy działanie (funkcja \code{after()}). Pierwsze z nich to komenda
sprawdzająca sumę kontrolną przesyłanego pliku korzystając z polecenia
\code{md5sum}. Drugie powoduje powiadomienie Arete Master o zakończeniu
działania. Ponieważ \fixme{trigger} o nazwie \code{kill-server} czeka tylko na
jedno powiadomienie, Arete Slave otrzyma dzięki niemu sygnał do wykonania
komendy kończącej działanie serwera.

\begin{pythoncode}
  append_schedule('server', [
      ('server', at(0), \
          shell('./@{serverdist.path} 0.0.0.0 6666', use_resources=['serverdist'], \
	  check_executable=False)),
      ('trigger', trigger('kill-server'), shell('kill @{server.pid}')),
      ('ls', after('server'), shell('ls dest_path')),
      ('md5sum', after('ls'), shell('md5sum dest_path')),
      ('rm', after('md5sum'), shell('rm -f dest_path'))
  ])
\end{pythoncode}

W przypadku serwera na początku uruchamiany jest program \code{Server.py} z
odpowiednimi parametrami. Podobnie jak w kliencie przesyłane są wymagane zasoby
oraz flaga \code{check\_executable} ustawiana jest na \code{False}. Następnie
tworzona jest komenda kończąca działanie komendy \code{server}, która zostanie
uruchomiona po otrzymaniu sygnału o nazwie \code{kill-server} od modułu Arete
Master. Pozwoli to na uruchomienie dalszych komend, sprawdzających nazwę oraz
sumę kontrolną otrzymanego od klienta pliku, usunięcie go oraz zakończenie
testu.

\subsection{Uruchomienie}


Uruchamiamy Arete Slave na komputerach biorących udział w teście.

\code{\$ arete-slave -v}

Następnie tworzymy laboratorium. Może ono przykładowo wyglądać tak:

\begin{pythoncode}
  create_laboratory('example-laboratory')

  add_device('marvin',
      connection='tcp',
      ip='192.168.0.2',
      port='4567',
      frontend='arete_slave')

  add_device('defteros',
      connection='tcp',
      ip='192.168.0.3',
      port='4567',
      frontend='arete_slave')
\end{pythoncode}

Odwzorowanie.

\begin{pythoncode}
  create_mapping('example-mapping')

  bind('client', 'marvin')
  bind('server', 'defteros')
\end{pythoncode}

Aby rozpocząć test uruchamiamy Arete Master.

\code{\$ arete -c examples/client-server/configuration example\_laboratory --map client:marvin server:defteros}



\subsection{Przebieg}

\begin{figure}[htb]
\begin{center}
\leavevmode
\includegraphics[width=0.8\textwidth]{example-01-sequence}
\end{center}
\caption{Schemat przebiegu testu klient-serwer.}
\label{fig:example-01-sequence}
\end{figure}

\subsection{Wyniki}

\FIXME{Zaprezentowanie jak wyglądają otrzymane wyniki, że się sumy kontrolne
zgadzają itt (i takie tam).}

\section{Przykład: DCCP}

\FIXME{tmp}

Drugi scenariusz dotyczy pomiaru szybkości transferu danych przy użyciu
protokołu DCCP (Datagram Congestion Control Protocol) oraz wpływu innych
transmisji na tę szybkość. Sposób pomiaru jest prosty. Wykorzystujemy program
\code{iperf}, który umożliwia uruchomienie serwera i klienta wybranego
protokołu. Klient transmituje do serwera strumień losowych danych korzystając
ze wskazanego protokołu transportowego i zapamiętuje uzyskaną szybkość
transmisji. Dodatkowo, przy użyciu reguł \code{iptables} mierzy się ilość
pakietów i bajtów całego ruchu sieciowego.

Stworzyliśmy kilka różnych testów badających m.in.: samodzielną pracę DCCP,
wpływ transmisji TCP i UDP na pracę DCCP, porównanie DCCP z TCP i UDP, itd.
Różniły się one kolejnością i momentami, w których na uczestniczących w teście
urządzeniach należało uruchomić lub zakończyć \code{iperf}.

Aby zautomatyzować te testy, program musi:
\begin{enumerate}
\item korzystając z interfejsu \code{sysctl} skonfigurować parametry DCCP,
\item stworzyć reguły \code{iptables} do mierzenia ruchu,
\item przeprowadzić synchronizację, 
\item rozpocząć test,
\item w wyznaczonych momentach rozpocząć lub zakończyć działanie \code{iperf},
\item zbierać wartości liczników \code{iptables},
\item zapamiętać wszystkie uzyskiwane wyniki,
\item przywrócić opcje DCCP i konfigurację \code{iptables}.
\end{enumerate}

Ważne jest też, żeby w czasie testu program nie przesyłał żadnych danych, aby
nie wpływał na uzyskiwane wyniki.

\subsection{Konfiguracja}

\FIXME{Konfiguracja.}

\begin{pythoncode}
  class IPTablesCounters(HostDriverPlugin):
      def process(self, cmd, host, attributes):
          if 'iptables_counters' not in attributes:
              return 

          protocols = host.model['iptables_counters']

          cmd.add_setup('iptables -F')
          for proto in protocols:
              cmd.add_setup('iptables -I INPUT -p {0}'.format(proto))
              cmd.add_setup('iptables -I OUTPUT -p {0}'.format(proto))

          cmd.add_cleanup('iptables -F')

          attributes.remove('iptables_counters')
\end{pythoncode}

\begin{pythoncode}
  create_model('dccp_flow')

  add_host('client', iptables_counters=['33', 'tcp', 'udp']) # 33 is DCCP
  add_host('server', iptables_counters=['33', 'tcp', 'udp'])
\end{pythoncode}

\begin{pythoncode}
  create_schedule('dccp_flow')
  test_end_policy('duration 20', setup_phase_delay=2.0)
\end{pythoncode}

\begin{pythoncode}
  dccp = ClientServer('dccp',
      server_command='iperf -s -p 7999 -d', # -d is for DCCP
      client_command='iperf -c @{server.ip} -p 7999 -d -t 18') # -d is for DCCP

  tcp = ClientServer('tcp',
      server_command='iperf -s -p 7998',
      client_command='iperf -c @{server.ip} -p 7998 -t 9')
\end{pythoncode}

\begin{pythoncode}
  append_schedule('server', dccp.server(start=0, end=20))
  append_schedule('client', dccp.client(start=1, end=None, server='server'))

  append_schedule('server', tcp.server(start=0, end=20))
  append_schedule('client', tcp.client(start=10, end=None, server='server'))

  append_schedule('server', [('counters', every(1), shell('iptables -L -v -n -Z -x'))])
  append_schedule('client', [('counters', every(1), shell('iptables -L -v -n -Z -x'))])
\end{pythoncode}

\subsection{Uruchomienie}

\FIXME{Uruchomienie.}

\subsection{Przebieg}

\FIXME{Przebieg.}

\begin{figure}[htb]
\begin{center}
\leavevmode
\includegraphics[width=0.8\textwidth]{example-03-sequence}
\end{center}
\caption{Schemat przebiegu testu dccp.}
\label{fig:example-03-sequence}
\end{figure}

\subsection{Wyniki}

\FIXME{Wyniki.}

\section{Przykład: Torrent}

\FIXME{tmp}

Trzeci scenariusz, który mieliśmy na uwadze, to ćwiczenie laboratoryjne z
Systemów Peer-to-Peer. Test polega na pomiarze czasu dystrybucji pliku w sieci
BitTorrent. Klienci mają rozpocząć pobieranie w tym samym momencie, a test należy
zakończyć kiedy wszyscy będą posiadać pełny plik. Interesuje nas, ile każdy
klient wysłał danych i ile trwała pełna dystrybucja pliku. Zadana topologia
urządzeń to dwie sieci IP po cztery urządzenia, połączone routerem sztucznie
generującym opóźnienia.

Program w tym teście:
\begin{enumerate}
\item do każdego uczestnika wysyła plik torrent,
\item konfiguruje interfejsy routera,
\item konfiguruje adresy sieciowe uczestników,
\item jednocześnie uruchamia klientów sieci BitTorrent,
\item oczekuje aż każdy otrzyma pełny plik,
\item zatrzymuje klientów,
\item zapamiętuje wyniki,
\item przywraca konfigurację.
\end{enumerate}

\subsection{Konfiguracja}

\FIXME{Konfiguracja.}



\begin{pythoncode}
  create_schedule('torrent-distribution-time')
    
  test_end_policy('complete', setup_phase_delay=0.0)
  create_trigger('stop-torrent', len(west+east)-1)
\end{pythoncode}

\begin{pythoncode}
  torrent = add_resource(File('torrent', 'big-data-file.torrent'))
  data    = add_resource(File('big-data-file',    'big-data-file'))
  trackcfg = add_resource(File('trackcfg', 'xbt_tracker.conf'))
\end{pythoncode}

\begin{pythoncode}
  tracker_schedule = [
      ('tracker', at(0), shell('xbt_tracker --conf_file @{trackcfg.path}', \
          use_resources=[trackcfg])),
      ('stop-tracker', trigger('stop-torrent'), shell('kill @{tracker.pid}'))
  ]
\end{pythoncode}

\begin{pythoncode}
  seed_schedule = [ 
      ('ctorrent', at(1), shell('ctorrent -f "@{torrent.path}"', \
          use_resources=[torrent, data])),
      ('stop', trigger('stop-torrent'), shell('kill -9 @{ctorrent.pid}'))
  ]
\end{pythoncode}

\begin{pythoncode}
  peer_schedule = [
      ('ctorrent', at(2), \
          shell('ctorrent "@{torrent.path}" -X @{poke stop-torrent}', \
          use_resources=[torrent])),
      ('poke', poke('stop-torrent'), notify('stop-torrent')),
      ('stop', trigger('stop-torrent'), shell('kill -9 @{ctorrent.pid}'))
  ]
\end{pythoncode}

\begin{pythoncode}
  append_schedule(east[0], tracker_schedule)
  append_schedule(east[0], seed_schedule)

  for host in west + east[1:]:
      append_schedule(host, peer_schedule)
\end{pythoncode}

\subsection{Uruchomienie}

\FIXME{Uruchomienie.}

\subsection{Przebieg}

\FIXME{Przebieg.}

\begin{figure}[htb]
\begin{center}
\leavevmode
\includegraphics[width=0.8\textwidth]{example-02-sequence}
\end{center}
\caption{Schemat przebiegu testu torrent.}
\label{fig:example-02-sequence}
\end{figure}

\subsection{Wyniki}

\FIXME{Wyniki.}

\end{document}
