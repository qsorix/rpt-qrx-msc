\documentclass[00-praca-magisterska.tex]{subfiles}
\begin{document}

\chapter{Przykłady}

\section{Instalacja}

\FIXME{Opis instalacji Arete.}

\section{Przykład: Klient-serwer}

Pierwszym przykładem który omówimy jest prosty scenariusz, z którym często mamy
do czynienia w czasie tworzenia oprogramowania typu klient-serwer. W naszym
przypadku będzie to program umożliwiający transfer plików, gdzie zarówno serwer
jak i klient będą sterowane z linii poleceń. W teście będziemy chcieli sprawdzić
czy transfer przebiegł poprawnie, tj. czy zawartość przesłanego pliku jest
identyczna i czy zgadza się jego nazwa.

W przykładzie wykorzystaliśmy proste aplikacje napisane w języku Python, których
kod zamieszczamy poniżej. Klient łączy się z serwerem i korzystając z protokołu
TCP przesyła nazwę i zawartość wskazanego pliku. Serwer nasłuchuje na
przychodzące połączenia i odbiera nazwę oraz zawartość transmitowanego pliku, a
następnie zapisuje go w lokalnym systemie plików.

\begin{pythoncode}
  # Client.py:
  import sys
  import socket

  if __name__ == "__main__":
      if len(sys.argv) != 5:
	  print >>sys.stderr, \
	      "Usage: {0} <ip> <port> <file> <destname>".format(sys.argv[0])
	  sys.exit(1)

      ip = sys.argv[1]
      port = int(sys.argv[2])
      filename = sys.argv[3]
      destname = sys.argv[4]

      sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
      sock.connect((ip, port))

      sock.send(destname+'\n')

      with open(filename, 'r') as file:
          sock.sendall(file.read())

      sock.close()

      print 'transfer done'

\end{pythoncode}

\begin{pythoncode}
  # Server.py:
  import sys
  import SocketServer

  class FileTransferHandler(SocketServer.BaseRequestHandler):
      def handle(self):
          input  = self.request.makefile('r', 0)
          filename = input.readline().strip()

          print 'received', filename

          with open(filename, 'w') as file:
	      file.write(input.read())
  
          self.request.close()

  if __name__ == "__main__":
      if len(sys.argv) != 3:
          print >>sys.stderr, "Usage: {0} <ip> <port>".format(sys.argv[0])
          sys.exit(1)

      ip = sys.argv[1]
      port = int(sys.argv[2])

      server = SocketServer.TCPServer((ip, port), FileTransferHandler)
      server.serve_forever()

\end{pythoncode}

\subsection{Konfiguracja}

Poniżej omówiliśmy szczegółowo konfigurację testu. Zawiera ona jedynie model i
plan testu, natomiast laboratorium i odzworowanie między modelem a laboratorium
zostaną przedstawione później. Zakładamy, że użytkownik zapoznał się z działem
\fixref{Konfiguracja}.

\begin{pythoncode}
  # examples/client-server/configuration:
  create_model('client-server')

  add_host('client')
  add_host('server')
\end{pythoncode}

Na początku tworzymy model o nazwie \code{client-server}. Ponieważ do
przeprowadzenia testu potrzebujemy dwóch urządzeń - klienta i serwer, dodajemy
je do stworzonego modelu. 

\begin{pythoncode}
  create_schedule('client-server')

  test_end_policy('complete', setup_phase_delay=0.0)
  create_trigger('kill-server', 1)
\end{pythoncode}

Tworzymy również plan testu \code{client-server}, aby móc określić jakie
komendy będę wykonywane na urządzeniach, a następnie konfigurujemy globalne
ustawienia testu. Ponieważ ciężko przewidzieć nam jak długo potrwa test,
ustawiamy politykę zakończenia testu na \code{complete}. Spowoduje to
zakończenie testu dopiero w momencie, gdy zakończy się on na wszystkich
urządzeniach biorących w nim udział. Zwróćmy uwagę, że jednym z urządzeń jest
serwer, który z założenia nie kończy swojego działania. Z tego powodu tworzymy
wyzwalacz o nazwie \code{kill-server}, mający za zadanie zakończyć działanie
serwera, gdy określona ilość urządzeń (w naszym przypadku jeden klient),
powiadomi o zakończeniu testu. Wartość tę podajemy jako drugi parametr komendy
\code{create\_trigger}.  W komendzie \code{test\_end\_policy} jak parametr
\code{setup\_phase\_delay} podajemy czas potrzebny na uruchomienie komend
konfiguracyjnych. W naszym przypadku czas ten wynosi \code{0.0} ponieważ nie
jest wymagana dodatkowa konfiguracja.

\begin{pythoncode}
  add_resource(File('clientdist', 'Client.py', chmod='+x'))
  add_resource(File('serverdist', 'Server.py', chmod='+x'))
  add_resource(File('testfile', 'datafile.txt'))
\end{pythoncode}

Kolejnym etapem jest dodanie zasobów biorących udział w teście. Będą to
oczywiście programy \code{Client.py} oraz \code{Server.py}. Aby zapewnić im
odpowiednie prawa po przesłaniu na zdalne urządzenia, koszystamy z parametru
\code{chmod}. Jako trzeci dodajemy plik który zostanie przesłany między
urządzeniami.

\begin{pythoncode}
  append_schedule('client', [
      ('client', at(1), \
          shell('./@{clientdist.path} @{server.ip} 6666 @{testfile.path} dest_path', \
          use_resources=['clientdist', 'testfile'], check_executable=False)),
      ('md5sum', after('client'), shell('md5sum @{testfile.path}')),
      ('notify', after('md5sum'), notify('kill-server'))
  ])
\end{pythoncode}

Najważniejszą częścią konfiguracji jest określenie szczegółowego planu
wykonywania komend na urządzeniach. W przypadku klienta uruchamiamy program
\code{Client.py} z odpowiednimi parametrami, tj. adresem i portem serwera, nazwą
pliku który zostanie przesłany oraz docelową nazwą pliku. W parametrze
\code{use\_resources} podajemy nazwy stworzonych wcześniej zasobów. Parametr
\code{check\_executable=False} zapobiega sprawdzeniu czy komenda którą chcemy
wykonać jest wykonywalna, ponieważ sami zadbaliśmy o to nadając plikom
odpowiednie prawa podczas ich tworzenia. Zwróćmy uwagę, że komenda \code{client}
uruchamiana jest z sekundowym opóźnieniem (\code{at(1)}), aby pozostawić czas na
uruchomienie serwera.

Następnie dodajemy dwa zadania, które będą wykonywane gdy program klienta
zakończy działanie (funkcja \code{after()}). Pierwsze z nich to komenda
sprawdzająca sumę kontrolną przesyłanego pliku korzystając z polecenia
\code{md5sum}. Drugie powoduje powiadomienie Arete Master o zakończeniu
działania. Ponieważ wyzwalacz o nazwie \code{kill-server} czeka tylko na
jedno powiadomienie, Arete Slave otrzyma dzięki niemu sygnał do wykonania
komendy kończącej działanie serwera.

\begin{pythoncode}
  append_schedule('server', [
      ('server', at(0), \
          shell('./@{serverdist.path} 0.0.0.0 6666', \
          use_resources=['serverdist'], check_executable=False)),
      ('trigger', trigger('kill-server'), shell('kill @{server.pid}')),
      ('ls', after('server'), shell('ls dest_path')),
      ('md5sum', after('ls'), shell('md5sum dest_path')),
      ('rm', after('md5sum'), shell('rm -f dest_path'))
  ])
\end{pythoncode}

W przypadku serwera na początku uruchamiany jest program \code{Server.py} z
odpowiednimi parametrami. Podobnie jak w kliencie przesyłane są wymagane zasoby
oraz flaga \code{check\_executable} ustawiana jest na \code{False}. Następnie
tworzona jest komenda kończąca działanie komendy \code{server}, która zostanie
uruchomiona po otrzymaniu sygnału o nazwie \code{kill-server} od modułu Arete
Master. Pozwoli to na uruchomienie dalszych komend, sprawdzających nazwę oraz
sumę kontrolną otrzymanego od klienta pliku, usunięcie go oraz zakończenie
testu.

\subsection{Uruchomienie}

Rozpoczynamy od uruchomienia programów Arete Slave na komputerach biorących
udział w teście.

\code{\$ arete-slave -v}

Ponieważ na każdym z urządzeń będzie działać tylko jeden demon, możemy
skorzystać z domyślnych ustawień. W przeciwnym wypadku wymagane jest użycie
dodatkowych parametrów opisancych w rozdziale \ref{arete-slave-run}, aby
zróżnicować porty i nazwy plików bazy danych. Użycie parametru \code{-v}
spowoduje wypisywanie loga na standardowe wyjście, co ułatwi nam obserwację
przebiegu testu.

Następnie tworzymy konfigurację laboratorium. Przykładowy plik konfiguracyjny
przedstawiono poniżej.

\begin{pythoncode}
  # examples/example_laboratory:
  create_laboratory('example_laboratory')

  add_device('marvin',
      connection='tcp',
      ip='192.168.0.2',
      port='4567',
      frontend='arete_slave')

  add_device('defteros',
      connection='tcp',
      ip='192.168.0.3',
      port='4567',
      frontend='arete_slave')
\end{pythoncode}

Kolejnym krokiem jest stworzenie odwzorowania między modelem a labolatorium.
Jeśli chcielibyśmy zawrzeć go w pliku konfiguracyjnym, wyglądałoby to
następująco.

\begin{pythoncode}
  create_mapping('model-to-laboratory')

  bind('client', 'marvin')
  bind('server', 'defteros')
\end{pythoncode}

Dla uproszczenia odwzorowanie podamy jednak jako argument programu Arete Master.
Uruchamiamy test uwzględniając stworzone wcześniej pliki konfiguracyjne oraz
odwzorowanie, jak przedstawiono poniżej.

\code{\$ arete -c examples/client-server/configuration examples/example\_laboratory --map client:marvin server:defteros}

\subsection{Przebieg}

\begin{figure}[htb]
\begin{center}
\leavevmode
\includegraphics[width=0.6\textwidth]{example-01-sequence}
\end{center}
\caption{Schemat przebiegu testu klient-serwer.}
\label{fig:example-01-sequence}
\end{figure}

Prześledźmy teraz zobrazowany na rysunku \ref{fig:example-01-sequence} przebieg
testu. Zaczynamy od wystartowania serwera (\code{1}) na urządzeniu \code{server}.
Następnie na drugim urządzeniu uruchamiany jest klient (\code{2}), który łączy się z
serwerem, przesyła do niego wskazany plik. Po zakończeniu transferu klient kończy
działanie i uruchamiane jest obliczenie sumy kontrolnej (\code{3}) oraz wysyłane
jest powiadomienie (\code{4}) do modułu Arete Master. Ten wysyła wyzwalacz do
Arete Slave na urządzeniu \code{server}, który odbiera go (\code{5}) i kończy
pracę serwera. Na koniec na urządzeniu \code{server} sprawdzana jest nazwa pliku
(\code{6}) oraz suma kontrolna (\code{7}), a następnie przesłany plik jest
usuwany (\code{8}).

\subsection{Wyniki}

Po zakończeniu testu Arete Master odbiera wyniki od obu modułów Slave
uczestniczących w teście i zapisuje je do swojej bazy danych. W tym przykładzie
wyglądają one następująco.

\begin{description}
\item[]
  node: client
  \begin{description}
  \item[start time] 2010-11-14 21:46:46.171340
  \item[duration] 1.442621
  \item[]
    command: 'client'
    \begin{description}
      \item[output] transfer done
      \item[start time] 2010-11-14 21:46:47.171994
      \item[duration] 0.049891
      \item[return code] 0
    \end{description}
  \item[]
    command: 'md5sum'
    \begin{description}
      \item[output] 015f88fc887a556bf7eab90ec32c8c46  testfile
      \item[start time] 2010-11-14 21:46:47.371130
      \item[duration] 0.057670
      \item[return code] 0
    \end{description}
  \end{description}
\item[]
  node: server
  \begin{description}
  \item[start time] 2010-11-14 21:46:46.172080
  \item[duration] 1.802907
  \item[]
    command: 'server'
    \begin{description}
      \item[output] 
      \item[start time] 2010-11-14 21:46:46.179522
      \item[duration] 1.532876
      \item[return code] -15
    \end{description}
  \item[]
    command: 'ls'
    \begin{description}
      \item[output] dest\_path
      \item[start time] 2010-11-14 21:46:47.733533
      \item[duration] 0.056964
      \item[return code] 0
    \end{description}
  \item[]
    command: 'md5sum'
    \begin{description}
      \item[output] 015f88fc887a556bf7eab90ec32c8c46  dest\_path
      \item[start time] 2010-11-14 21:46:47.823826
      \item[duration] 0.049728
      \item[return code] 0
    \end{description}
  \end{description}
\end{description}

Jak widzimy w bazie danych oprócz informacji dotyczących całego testu, takich
jak czas jego rozpoczęcia i długość trwania na każdym z komputerów, mamy do
dyspozycji szczegółowe dane na temat każdej z wykonanych komend, tj. wyjście,
zwrócony kod wyjścia, czas rozpoczęcia oraz długość trwania.

Choć interpretacja wyników nie jest celem naszej pracy, w tym prostym przypadku
możemy zaobserwować, że nazwa pliku otrzymana z komendy ls na serwerze jest
poprawna, a sumy kontrolne na obu urządzeniach są zgodne. Możemy zatem
wywnioskować, że stworzone przez nas implementacje programów klient-serwer są
poprawne.

\section{Przykład: DCCP}

Drugi przykład dotyczy pomiaru szybkości transferu danych przy użyciu protokołu
DCCP oraz wpływu innych transmisji na tę szybkość. Sposób pomiaru jest prosty.
Wykorzystujemy program \code{iperf}, który umożliwia uruchomienie serwera i
klienta wybranego protokołu. Klient transmituje do serwera strumień losowych
danych korzystając ze wskazanego protokołu transportowego i zapamiętuje uzyskaną
szybkość transmisji. Dodatkowo, przy użyciu reguł \code{iptables} mierzy się
ilość pakietów i bajtów całego ruchu sieciowego.

Stworzyliśmy kilka różnych testów badających m.in.: samodzielną pracę DCCP,
wpływ transmisji TCP i UDP na pracę DCCP, porównanie DCCP z TCP i UDP, itd.
Różniły się one kolejnością i momentami, w których na uczestniczących w teście
urządzeniach należało uruchomić lub zakończyć \code{iperf}. W tym przykładzie
zaprezentujemy test przedstawiający wpływ transmisji TCP na pracę DCCP. 

\subsection{Konfiguracja}

\begin{pythoncode}
  class IPTablesCounters(HostDriverPlugin):
      def process(self, cmd, host, attributes):
          if 'iptables_counters' not in attributes:
              return 

          protocols = host.model['iptables_counters']

          cmd.add_setup('iptables -F')
          for proto in protocols:
              cmd.add_setup('iptables -I INPUT -p {0}'.format(proto))
              cmd.add_setup('iptables -I OUTPUT -p {0}'.format(proto))

          cmd.add_cleanup('iptables -F')

          attributes.remove('iptables_counters')
\end{pythoncode}

Zaczynamy od stworzenia \fixme{sterownika parametrów} (\code{HostDriverPlugin}),
który dla każdego z urządzeń doda komendy konfiguracyjne i czyszczące tworzące
odpowiednie wpisy w \code{iptables} dla podanych protokołów.

\begin{pythoncode}
  create_model('dccp_flow')

  add_host('client', iptables_counters=['33', 'tcp', 'udp'])
  add_host('server', iptables_counters=['33', 'tcp', 'udp'])
\end{pythoncode}

Następnie tworzymy model o nazwie \code{dccp\_flow} i podobnie jak w poprzednim
przykładzie dodajemy dwa urządzenia - klienta i serwer. W parametrze
\code{iptables\_counters} podajemy listę protokołów dla wcześniej stworzonego
\fixme{sterownika parametrów}. Liczba \code{33} odpowiada protokołowi DCCP.

\begin{pythoncode}
  create_schedule('dccp_flow')

  test_end_policy('duration 20', setup_phase_delay=2.0)
\end{pythoncode}

Tworzymy także plan testu o nazwie \code{dccp\_flow}. Ponieważ ważne jest, żeby
w czasie testu program nie przesyłał żadnych nadmiarowych danych, które
wpłynęłyby na uzyskane wyniki, ustawiamy czas trwania testu na stałą wartość
\code{20} sekund. Spowoduje to rozłączenie się Arete Master po przesłaniu testu
i ponowne połączenie po zakończeniu testu. Ponieważ test wymaga wykonania komend
konfiguracyjnych ustawiamy opóźnienie testu na \code{2.0} korzystając z
parametru \code{setup\_phase\_delay}.

\begin{pythoncode}
  dccp = ClientServer('dccp',
      server_command='iperf -s -p 7999 -d',
      client_command='iperf -c @{server.ip} -p 7999 -d -t 18')

  tcp = ClientServer('tcp',
      server_command='iperf -s -p 7998',
      client_command='iperf -c @{server.ip} -p 7998 -t 9')
\end{pythoncode}

Korzystając z gotowej klasy \code{ClientServer} z modułu \code{Utils} tworzymy
komendy uruchamiające \code{iperf} w trybie klienta (\code{-c}) oraz serwera
(\code{-s}) dla protokołów DCCP (opcja \code{-d}) oraz TCP.

\begin{pythoncode}
  append_schedule('server', dccp.server(start=0, end=20))
  append_schedule('client', dccp.client(start=1, end=None, server='server'))

  append_schedule('server', tcp.server(start=0, end=20))
  append_schedule('client', tcp.client(start=10, end=None, server='server'))

  append_schedule('server', [('counters', every(1), \
      shell('iptables -L -v -n -Z -x'))])
  append_schedule('client', [('counters', every(1), \
      shell('iptables -L -v -n -Z -x'))])
\end{pythoncode}

Na koniec dodajemy do planu testu stworzone wcześniej komendy. Na urządzeniu
\code{server} dodajemy serwery DCCP i TCP, które działać będą przez cały czas
trwania testu. Na urządzeniu \code{client} w \code{1} sekundzie uruchamiamy
klienta DCCP, a w \code{10} sekundzie klienta TCP. Na obu urządzeniach co
sekundę zapisujemy wynik komendy wypisującej ilość przesłanych pakietów i
bajtów.

\subsection{Uruchomienie}

Należy zwrócić uwagę, że przykład ten wymaga uprawnień administratora.

Podobnie jak w poprzednim przykładzie najpierw uruchamiamy programy Arete Slave
na komputerach biorących udział w teście.

\code{\# arete-slave -v}

Następnie korzystając ze stworzonego już pliku z konfiguracją laboratorium i
argumentu \code{--map} uruchamiamy test w programie Arete Master.

\code{\# arete -c examples/dccp\_flow/configuration examples/example\_laboratory
-- map client:marvin server:defteros}

\subsection{Przebieg}

\FIXME{Opisać przebieg.}

\begin{figure}[htb]
\begin{center}
\leavevmode
\includegraphics[width=0.8\textwidth]{example-03-sequence}
\end{center}
\caption{Schemat przebiegu testu dccp.}
\label{fig:example-03-sequence}
\end{figure}

\subsection{Wyniki}

\FIXME{Wyniki.}

\section{Przykład: Torrent}

Trzeci, ostatni przykład, który przedstawimy, to ćwiczenie laboratoryjne z
Systemów Peer-to-Peer. Test polega na pomiarze czasu dystrybucji pliku w sieci
BitTorrent. Klienci mają rozpocząć pobieranie w tym samym momencie, a test należy
zakończyć kiedy wszyscy będą posiadać pełny plik. Interesuje nas, ile każdy
klient wysłał danych i ile trwała pełna dystrybucja pliku.

\FIXME{"Zadana topologia urządzeń to dwie sieci IP po cztery urządzenia,
połączone routerem sztucznie generującym opóźnienia." - różne sytuacje, tu
opiszemy jedną.}

\subsection{Konfiguracja}

\FIXME{Dodać jakiś model.}

\begin{pythoncode}
  create_schedule('torrent')
    
  test_end_policy('complete', setup_phase_delay=0.0)
  create_trigger('stop-torrent', len(west+east)-1)
\end{pythoncode}

\begin{pythoncode}
  torrent = add_resource(File('torrent', 'big-data-file.torrent'))
  data    = add_resource(File('big-data-file',    'big-data-file'))
  trackcfg = add_resource(File('trackcfg', 'xbt_tracker.conf'))
\end{pythoncode}

\begin{pythoncode}
  tracker_schedule = [
      ('tracker', at(0), shell('xbt_tracker --conf_file @{trackcfg.path}', \
          use_resources=[trackcfg])),
      ('stop-tracker', trigger('stop-torrent'), shell('kill @{tracker.pid}'))
  ]
\end{pythoncode}

\begin{pythoncode}
  seed_schedule = [ 
      ('ctorrent', at(1), shell('ctorrent -f "@{torrent.path}"', \
          use_resources=[torrent, data])),
      ('stop', trigger('stop-torrent'), shell('kill -9 @{ctorrent.pid}'))
  ]
\end{pythoncode}

\begin{pythoncode}
  peer_schedule = [
      ('ctorrent', at(2), \
          shell('ctorrent "@{torrent.path}" -X @{poke stop-torrent}', \
          use_resources=[torrent])),
      ('poke', poke('stop-torrent'), notify('stop-torrent')),
      ('stop', trigger('stop-torrent'), shell('kill -9 @{ctorrent.pid}'))
  ]
\end{pythoncode}

\begin{pythoncode}
  append_schedule(east[0], tracker_schedule)
  append_schedule(east[0], seed_schedule)

  for host in west + east[1:]:
      append_schedule(host, peer_schedule)
\end{pythoncode}

\subsection{Uruchomienie}

\FIXME{Uruchomienie.}

\subsection{Przebieg}

\FIXME{Opisać przebieg.}

\begin{figure}[htb]
\begin{center}
\leavevmode
\includegraphics[width=0.8\textwidth]{example-02-sequence}
\end{center}
\caption{Schemat przebiegu testu torrent.}
\label{fig:example-02-sequence}
\end{figure}

\subsection{Wyniki}

\FIXME{Wyniki.}

\end{document}
