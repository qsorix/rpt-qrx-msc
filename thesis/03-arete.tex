\documentclass[00-praca-magisterska.tex]{subfiles}
\begin{document}

\chapter{Arete}

W tym rozdziale prezentujemy stworzone przez nas narzędzie Arete -- Automated
Real Environment Testing Engine. Jego zadaniem jest automatyzacja
powtarzających się czynności występujących przy przeprowadzaniu testów w
środowiskach rozproszonych w warunkach rzeczywistych.

Omówienie rozpoczynamy od przedstawienia, popartych przykładami, zastosowań, z
myślą o których stworzone zostało Arete. Są to sytuacje, w których nasze
narzędzie pozwoli usprawnić pracę osób przeprowadzających testy.

Następnie opisujemy wynikające z zastosowań wymagania funkcjonalne. Wymagania
te krótko podsumowują podstawowe możliwości programu.

W dalszej części prezentujemy dodatkowe założenia mające wpływ na charakter
tworzonego rozwiązania, jednocześnie argumentując podjęte przez nas decyzje w
świetle jego użyteczności.

Rozdział zamyka prezentacja architektury programu.

\section{Zastosowania}

Arete zostało stworzone z myślą o testerach, zespołach badawczych oraz
studentach kierunków informatycznych, zajmujących się tworzeniem oprogramowania
sieciowego lub przeprowadzaniem eksperymentów w sieciach komputerowych. Może być
ono również przydatne dla prowadzących zajęcia praktyczne, przygotowujących
ćwiczenia w takich środowiskach.

Tworząc Arete skupiliśmy się na kilku przypadkach zastosowań, które pojawiły
się w czasie naszych zajęć laboratoryjnych z różnych przedmiotów. Na uwadze
mieliśmy trzy konkretne scenariusze omówione poniżej.

Potrzebowaliśmy narzędzia, które zautomatyzuje najczęściej wykonywane
czynności: skonfiguruje maszyny, przeprowadzi testy, zapamięta wyniki i
przywróci pierwotną konfigurację.

Samo zaprojektowanie testu i stworzenie programów potrzebnych do jego
przeprowadzenia (m.in. programów mierzących obserwowane wartości) pozostaje w
kwestii użytkownika.

Najprostszy scenariusz ma miejsce w czasie tworzenia oprogramowania typu
klient-serwer. Załóżmy, że tworzymy prosty program mający umożliwiać transfer
plików. W teście chcemy sprawdzić czy transfer przebiegł poprawnie, tj. czy
zgadza się z nazwa pliku i czy jego zawartość jest identyczna.

Zadanie narzędzia polega tutaj na:
\begin{enumerate}
\item przesłaniu aktualnej implementacji serwera na wyznaczone urządzenie,
\item uruchomieniu serwera i klienta z odpowiednimi parametrami,
\item zakończeniu pracy serwera,
\item sprawdzeniu nazw i sum kontrolnych plików,
\item zapamiętaniu wyników z obu maszyn,
\item usunięcie pliku ze zdalnej maszyny.
\end{enumerate}

Drugi scenariusz dotyczy pomiaru szybkości transferu danych przy użyciu
protokołu DCCP (Datagram Congestion Control Protocol) oraz wpływu innych
transmisji na tę szybkość. Sposób pomiaru jest prosty. Wykorzystujemy program
\code{iperf}, który umożliwia uruchomienie serwera i klienta wybranego
protokołu, a przy użyciu reguł \code{iptables} mierzymy ilość pakietów i bajtów
całego ruchu sieciowego.

Aby zautomatyzować ten test, program musi:
\begin{enumerate}
\item korzystając z interfejsu \code{sysctl} skonfigurować parametry DCCP,
\item stworzyć reguły \code{iptables} do mierzenia ruchu,
\item przeprowadzić synchronizację, 
\item rozpocząć test,
\item w wyznaczonych momentach rozpocząć lub zakończyć działanie \code{iperf},
\item zbierać wartości liczników \code{iptables},
\item zapamiętać wszystkie uzyskiwane wyniki,
\item przywrócić opcje DCCP i konfigurację \code{iptables}.
\end{enumerate}

Ważne jest też, żeby w czasie testu program nie przesyłał żadnych danych, aby
nie wpływał w ten sposób na uzyskiwane wyniki.

Trzeci scenariusz, który mieliśmy na uwadze, to ćwiczenie laboratoryjne z
Systemów Peer-to-Peer. Test polega na pomiarze czasu dystrybucji pliku w sieci
BitTorrent rozpiętej nad dwiema sieciami IP. Klienci mają rozpocząć pobieranie
w tym samym momencie, a test należy zakończyć kiedy wszyscy będą posiadać pełny
plik. Interesuje nas, ile każdy klient wysłał danych i ile trwała pełna
dystrybucja pliku.

Program w tym teście:
\begin{enumerate}
\item do każdego uczestnika wysyła plik torrent,
\item konfiguruje interfejsy routera i pozostałych maszyn,
\item jednocześnie uruchamia klientów sieci BitTorrent,
\item oczekuje aż każdy otrzyma pełny plik,
\item zatrzymuje klientów,
\item zapamiętuje wyniki,
\item przywraca konfigurację.
\end{enumerate}

Do powyższych scenariuszy wracamy ponownie w rozdziale \fixref{Przykłady}. Są
tam one dokładnie omówione, przedstawiony jest też sposób przeprowadzenia ich
przy użyciu Arete.

Warto zauważyć, że w każdym ze wspomnianych scenariuszy test kończy się w
innym momencie. W pierwszym jest to moment, kiedy pracę zakończy dany program.
Testy z drugiego scenariusza kończą się w określonym momencie czasowym. W
ostatnim wypadku decyzja o zakończeniu jest podejmowana przez wszystkich
uczestników.

\section{Wymagania}

Lista poniżej zbiera wymagania stawiane przed programem we wprowadzeniu oraz te
wynikające z omówionych przed chwilą scenariuszy. W skład możliwości musi wchodzić:
\begin{itemize}
\item definiowanie testu,
\item łączenie ze zdalnymi urządzeniami,
\item konfiguracja zdalnych urządzeń,
\item przesyłanie zasobów\footnote{np.~pliki konfiguracyjne wykonywanych programów}  wymaganych w testach,
\item uruchamianie programów,
\item pobieranie wyników,
\item katalogowanie wyników wielu testów,
\item synchronizacja startu testu,
\item rozłączanie na czas wykonywania testu,
\item zakończenie testu w określony sposób:
  \begin{itemize}
  \item konkretny czas,
  \item wspólna decyzja uczestników testu,
  \item wyznaczony host kończy test.
  \end{itemize}
\end{itemize}

Powyższe wymagania mieliśmy na uwadze projektując projekt. Będziemy do nich
powracać w dalszej treści pracy, żeby wykazać, iż zostały one spełnione.

\section{Założenia}

Realizacja wymienionych w poprzedniej części wymagań wiązała się z podjęciem
wielu decyzji projektowych, które miały istotny wpływ na ogólny obraz tworzonego
programu.  Podejmując je kierowaliśmy się głównie chęcią stworzenia wygodnego i
prostego narzędzia.

\paragraph{Użytkownik wie, co robi.} Przyjęliśmy więc, że nie będziemy
wprowadzać rygorystycznej kontroli poprawności konfigurowanych akcji kosztem
funkcjonalności. Arete stara się ograniczać użytkownika w jak najmniejszym stopniu,
dzięki czemu może być wykorzystany w większej liczbie przypadków.

\paragraph{Bezpieczeństwo jest adekwatne do zagrożeń.} Aby możliwe było
przeprowadzenie pewnych testów, na urządzeniach wymagany jest dostęp w trybie
administratora. Ponieważ polecenia realizujące test przekazywane są zdalnie,
istnieje ryzyko wykorzystania ich do wykonania dowolnych komend z uprawnieniami
administratora. Nie niesie to jednak zagrożeń dla bezpieczeństwa gdyż środowisko
przeprowadzania testu zwykle odpowiada jego wymaganiom dotyczącym uprawnień w
dostępie.

Urządzenia w laboratoriach są przeznaczone do wykonywania na nich
eksperymentów.  Ich pierwotna konfiguracja jest po wykonaniu testów
przywracana. Sieci takie są najczęściej odizolowane, a wieć szansa zdalnego
dostępu do tego typu sieci jest znikoma.

Sieci domowe składają się z urządzeń, których administratorem jest właściciel i
najczęściej jest to ta sama osoba, która wykonuje test. Od sieci laboratoryjnych
konfiguracje takie różnią się zwykle faktem połączenia z Internetem i
występowaniem prywatnych danych. Dostęp z zewnątrz zwykle ograniczony jest przez
firewall routera. Użycie naszego programu nie powinno więc zwiększać
istniejącego ryzyka, w przypadku zastosowania go na urządzeniu pełniącym jego
rolę. Jednocześnie mamy pełne zaufanie do użytkowników sieci lokalnej.

Kwestie bezpieczeństwa są istotne w przypadku zastosowania naszego
oprogramowania w sieciach produkcyjnych jak sieć akademicka lub firmowy
intranet. W tego typu sieciach administracją zajmują się wyznaczone osoby.
Użytkownicy nie mają uprzywilejowanego dostępu do urządzeń i zwykle mogą
korzystać tylko z wyznaczonych systemów, na których muszą się uwierzytelniać.
Użytkownikom często nie wolno instalować własnego oprogramowania, a komunikacja
sieciowa jest ograniczana. W takich warunkach korzystanie z naszego programu
jest technicznie ograniczone do czynności, które użytkownik ma prawo wykonywać. 

Zadbaliśmy jednak o to, aby automatyzacja nie wymagała naruszania
bezpieczeństwa poufnych informacji. Zachęcamy użytkowników do korzystania z
mechanizmów autoryzacji przy użyciu kluczy szyfrujących. Nie zawsze jest to
możliwe i wtedy zwykle pozostają zwykłe hasła, zapewniliśmy jednak mechanizmy
dzięki którym nie trzeba ich wpisywać do konfiguracji, gdzie byłyby narażone na
dostęp przez osoby postronne.

\paragraph{Architektura Master-Slave.} Ponieważ wymagane jest, aby dało się
wykonywać test w sytuacji kiedy nie ma połączenia między urządzeniem, z którego
uruchamiamy test, a innym w teście uczestniczącym, konieczne było wprowadzenie
dodatkowego programu pomocniczego. Wyróżniamy więc program nadzorujący
przebieg testu (master), oraz programy wykonujące go (worker), zainstalowane na
występujących w teście urządzeniach.

Wprowadzenie takiej architektury powoduje, że instalacja programu wykonującego
testy (slave) zajmuje więcej czasu, trzeba ją bowiem przeprowadzić na
wszystkich systemach. Jest to jednak konieczne, w celu osiągnięcia
funkcjonalności wymaganej w pewnych scenariuszach testów, jak również przydatne
ze względów bezpieczeństwa.

W przypadkach, gdy na urządzeniu nie można zainstalować modułu
slave\footnote{Jak np.~większość routerów sprzętowych}, użytkownik ma możliwość
dostarczenia własnej wtyczki, dzięki której wciąż będzie można przeprowadzić
test. Więcej na ten temat w rozdziale \fixref{o wtyczkach typu FrontendPlugin}.

% FIXME: To jest przykład sytuacji, kiedy w teście występuje urządzenie bez
% modułu Slave, i powoduje to, że jakiegoś rodzaju testu się nie da
% przeprowadzić.
%
% Być może warto go przenieść do rozdziału o pluginach
%
% -----------------------------------------------------------------------------
% Przykładowo załóżmy, że chcemy przeprowadzić test mierzący ilość pakietów
% RIP\footnote{ang. Routing Information Protocol}, jakie routery wymieniają aby
% zapewnić poprawne tablice routingu po awarii łącza. Po połączeniu z routerem
% będziemy mieli możliwość wydania polecenia zatrzymującego wybrany interfejs.
% Jeżeli jednak jest to jednocześnie interfejs, którym się z routerem
% komunikujemy, a dane urządzenie nie będzie umożliwiać automatycznego
% przywrócenia pracy interfejsu, stracimy nad nim kontrolę.
% -----------------------------------------------------------------------------

\paragraph{Synchronizacja urządzeń nie zmienia wskazań ich zegarów.}
Najprostszym rozwiązaniem problemu synchronizacji byłoby wykorzystanie ogólnie
dostępnego protokołu synchronizacji czasu (np.~NTP) do ustawienia czasu
systemowego i następnie korzystanie z lokalnych wskazań tych zegarów. Takie
wyjście ma jednak dwie wady. Po pierwsze zmiana zegara nie jest dostępna na
wszystkich systemach. Po drugie, zmiana wskazań zegara w czasie pracy systemu
mogłaby zaburzyć pracę innych uruchomionych programów.

Z tego powodu wprowadziliśmy protokół synchronizacji, który oblicza różnice
między zegarami urządzeń i uwzględnia je przy wyznaczaniu czasu rozpoczęcia
testu.

Protokół ten po prostu wysyła do modułu slave zapytanie o lokalny czas
urządzenia, na którym jest uruchomiony. Zakładając symetryczny czas komunikacji
w obie strony, różnicę czasu można wyznaczyć wzorem: $$\Delta t = r - \frac{l_1
+ l_2}{2}$$ gdzie $r$ to wskazanie zegara zdalnego urządzenia w momencie
odebrania zapytania o czas a $l_1$ i $l_2$ to odpowiednio czasy wysłania
zapytania i odebrania odpowiedzi.

Synchronizacja ta jest domyślnie włączona, ale opcjonalna. Jeżeli testy
uruchamiamy w sieci, gdzie aktywny jest zewnętrzny protokół synchronizacji,
zegary urządzeń prawdopodobnie będą zsynchronizowane dokładniej i nasz prosty
protokół mógłby raczej pogorszyć sytuację.

\paragraph{Wszystkie wyniki są cenne.} Ponieważ obecnie przechowywanie dużych
ilości danych nie sprawia problemu, w czasie testu staramy się zebrać jak
najwięcej informacji. Ostatecznie to użytkownik decyduje o tym, co zostanie
zapamiętane, ale naszą myślą przewodnią było umożliwienie zapisania wszystkich
występujących w teście danych, takich jak wyjście programów, wytwarzane pliki,
kody wyjścia uruchamianych poleceń itp.

Ponadto staraliśmy się ułatwić katalogowanie danych, gdyż w przypadku
wielokrotnych uruchomień testu, szybko zbierają się ich duże ilości. Z tego
powodu do ich przechowywania korzystamy z bazy danych SQLite. Jest to naszym
zdaniem odpowiedni kompromis między możliwościami bazy danych a wygodą
przechowywania wyników w zwykłych plikach.

\paragraph{Narzędzie musi być elastyczne.} W czasie pracy zauważyliśmy, że
scenariusze różnego rodzaju testów wymagają różnych podejść. Projektując
aplikację uwzględniliśmy rozmaite przypadki, aby żadnego nie dyskryminować.
Zdajemy sobie jednak sprawę, że stworzenie gotowego narzędzia do przeprowadzania
wszystkich testów nie jest możliwe. Z tego powodu stworzyliśmy produkt
elastyczny, którego funkcjonalność w wielu miejscach można rozszerzać
samodzielnie. Dzięki temu możliwa jest obsługa różnego rodzaju urządzeń i
topologii sieciowych, jak również sposobów przeprowadzania testu.

\paragraph{Użytkownicy znają język Python.} Język Python jest wybranym przez nas
językiem implementacji jak i konfiguracji programu. Z tego powodu od
użytkowników wymagana jest jego podstawowa znajomość. Uważamy, że nie jest to
utrudnienie, ponieważ alternatywą byłoby wymaganie, aby użytkownik nauczył się
stosowanej przez nas, nowej składni plików konfiguracyjnych, a znajomość podstaw
języka Python jest bardziej uniwersalna.

Wybór języka Python był podyktowany jego popularnością, mamy więc nadzieję, że
spora część użytkowników odbierze to założenia jako zaletę, a nie wadę
produktu. Kolejną zaletą jest to, że jest on dostępny na wszystkich popularnych
systemach operacyjnych oraz domyślnie zainstalowany na większości systemów
Linuksowych.

Poczyniliśmy także założenia mówiące o tym, czego program robić nie będzie.

\paragraph{Analizę wyników pozostawiamy ekspertom.} Program ma pomóc w
pozyskaniu wyników określonych testów. Ich analiza byłaby ona trudna ze
względu na to, że z każdego rodzaju testu wyniki miałyby inny charakter. Poza
tym programy produkują dane w różnych formatach i nie sposób tego wcześniej
przewidzieć. Dostępne są specjalistyczne programy służące do przetwarzania tego
rodzaju danych pomiarowych, uznaliśmy za zbędne i niepoprawne naśladowanie ich
funkcjonalności.

\paragraph{Nie mamy wpływu na fizyczną topologię sieci.} Z oczywistych powodów
program nie ma wpływu na sposób w jaki połączone są urządzenia w laboratorium. W
tworzonych testach zakłada się, że użytkownik wie, jaki wpływ na wyniki testu ma
stworzona przez niego sieć. Program nie stara się analizować zastanej topologii.

\paragraph{Nie wymuszamy konfiguracji środowiska testu.} Przeprowadzając test w
rzeczywistej sieci prawdopodobnie celowo chcemy zbadać zachowanie implementacji
we współpracy z innymi uczestnikami sieci. Nasz program nie wymusza wyłączności
na komunikację sieciową ani nie monitoruje innych użytkowników sieci. Jeśli do
poprawnego przeprowadzenia pomiaru wymagane jest, aby testowany program był
jedynym użytkownikiem sieci, osoba wykonująca test sama musi o to zadbać.

\paragraph{O urządzeniach zakładamy jak najmniej.} Narzędzie Arete nie
wymaga od urządzeń biorących udział w teście żadnej funkcjonalności.
Dzięki temu jesteśmy w stanie obsługiwać zarówno tanie urządzenia sieciowe, o
bardzo ograniczonych możliwościach konfiguracyjnych, jak i w pełni wyposażone
systemu Uniksowe czy dedykowane routery. To użytkownik decyduje o tym, co w
danym teście mają robić występujące w nim urządzenia i tym samym stawia
im wymagania dotyczące zarówno funkcjonalności, jak i bezpieczeństwa.

\section{Architektura}

Rozpoczynając opis architektury powtórzmy jescze raz, że narzędzie Arete
pracuje w sieci komputerowej. Wyróżniamy komputer kontrolujący test, na którym
uruchomiony jest moduł Arete Master, oraz komputery uczestniczące w teście, na
których uruchomiony jest moduł Arete Slave.

Moduł Slave jest zaprojektowany jako demon pracujący przez cały czas. Master
natomiast uruchamiany jest tylko na czas trwania testu. Możliwa jest sytuacja,
w której moduł Slave zainstalowany jest na wszystkich komputerach w sieci.
Możliwe jest także uruchomienie kilku jego instancji na jednym urządzeniu.
Konfiguracja, w której moduł Master jest uruchomiany na urządzeniu, gdzie
jednocześnie pracuje moduł Slave jest dopuszczalne i jak najbardziej
prawidłowa.

\begin{figure}[htb]
\begin{center}
\leavevmode
\includegraphics[width=0.6\textwidth]{arete-arch}
\end{center}
\caption{Architektura narzędzia Arete.}
\label{fig:arete-arch}
\end{figure}

\begin{figure}[htb]
\begin{center}
\leavevmode
\includegraphics[width=0.7\textwidth]{arete-deploy}
\end{center}
\caption{Diagram wdrożenia narzędzia Arete.}
\label{fig:arete-deploy}
\end{figure}

Na rysunku \ref{fig:arete-deploy} widać przykładowe rozmieszczenie urządzeń w
sieci i ich rolę w czasie testu. W dalszej części pracy mowiąc o modułach
Master i Slave, jeśli nie precyzujemy, na jakich urządzeniach są uruchomione,
oznacza to, że fizyczna konfiguracja jest dowolna.

Architektura wewnętrzna modułów Master oraz Slave opisana jest w dwóch
kolejnych rozdziałach. Opis instalacji przedstawiamy w
\fixref{rozdziale Instalacja}. Tutaj natomiast przedstawiamy w jaki sposób
moduły te współpracują ze sobą, aby umożliwić przeprowadzenie testu.

\begin{figure}[htb]
\begin{center}
\leavevmode
\includegraphics[width=0.7\textwidth]{arete-test-sequence-deploy}
\end{center}
\caption{Przebieg testu. Faza przygotowywania testu.}
\label{fig:arete-test-seq-deploy}
\end{figure}

\begin{figure}[htb]
\begin{center}
\leavevmode
\includegraphics[width=0.55\textwidth]{arete-test-sequence-test}
\end{center}
\caption{Przebieg testu. Faza wykonywania testu.}
\label{fig:arete-test-seq-test}
\end{figure}

\begin{figure}[htb]
\begin{center}
\leavevmode
\includegraphics[width=0.55\textwidth]{arete-test-sequence-trigger}
\end{center}
\caption{Przebieg testu. Mechanizm powiadomień.}
\label{fig:arete-test-seq-trigger}
\end{figure}

\begin{figure}[htb]
\begin{center}
\leavevmode
\includegraphics[width=0.55\textwidth]{arete-test-sequence-results}
\end{center}
\caption{Przebieg testu. Faza pobierania wyników.}
\label{fig:arete-test-seq-results}
\end{figure}

Użytkownik rozpoczyna test uruchamiając moduł Master i przekazując mu zadaną
konfigurację testową. Master analizuje otrzymaną konfigurację i przygotowuje
plan działania dla poszczególnych urządzeń, a następnie przesyła im ją i
koordynuje ich pracę.

W celu spełnienia wymagań stawianych przed programem, wprowadziliśmy cztery
fazy przeprowadzenia testu.

Faza pierwsza to sprawdzenie poprawności. Slave po otrzymaniu konfiguracji
sprawdza, czy kontrolowane urządzenie jest w stanie przeprowadzić test. Faza ta
ma na celu eliminację oczywistych błędów, które wystąpiłyby w czasie testu, a
mogą być wcześnie i szybko wykryte. Przykładem możliwego kryterium poprawności
jest dostępność wszystkich komend, które mają zostać wykonane.

Faza druga to konfiguracja urządzenia. Slave na tym etapie wykonuje komendy,
które tymczasowo dostosują środowisko urządzenia do potrzeb testu. Możliwa jest
tutaj np. instalacje reguł zapory ogniowej czy konfiguracja interfejsu
sieciowego. Komendy te mogą uniemożliwić dalszą komunikację między modułami
Master i Slave. Z tego też powodu całość konfiguracji testu przesyłana jest
wcześniej.

Jeżeli na etapie konfiguracji nie wystąpią żadne błędy, Slave przechodzi do
fazy wykonania testu, tj. wykonania tych komend, na których faktycznie zależy
użytkownikowi.

Faza czwarta to przywrócenie konfiguracji. Wykonuje się ona zawsze, jeśli tylko
test osiągnął fazę konfiguracji. Komendy zdefiniowane w tej fazie powinny
przywrócić pierwotne środowisko pracy urządzenia, dzięki czemu moduł Master
ponownie ma możliwość nawiązania połączenia i pobrania wyników.

Jak widać, istnieje możliwość, że moduł Master przez długi czas trwania testu
będzie oczekiwał na jego zakończenie bez połączenia z modułem Slave. Jeśli test
ma trwać godzinę, a w pierwszych sekundach (w czasie fazy konfiguracji) wystąpi
błąd, test nie wykona się, ale Master dowie się o tym dopiero po godzinie.
Dlatego właśnie wcześniej występuje faza sprawdzenia poprawności, w czasie
której komunikacja jeszcze jest możliwa.

Na koniec Master zgłasza się do każdego modułu Slave i pobiera zgromadzone
wyniki wszystkich komend. Są one zapisywane w lokalnej bazie danych i stanowią
wyjście programu -- wynik testu.

\end{document}
