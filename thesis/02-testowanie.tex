\documentclass[00-praca-magisterska.tex]{subfiles}

\begin{document}

\chapter{Testowanie}
\label{testowanie}

Inżynieria oprogramowania bardzo szeroko omawia tematykę testów, na każdym
kroku podkreślając wagę i nieodłączność tej fazy w procesie tworzenia
oprogramowania.  Powstający produkt testuje się między innymi, aby zapewnić jak
najwyższą jakość dostarczanego oprogramowania. Pod tym ogólnym stwierdzeniem
często rozumie się co innego, w zależności od rodzaju i przeznaczenia programu.
Dlatego też w tym rozdziale przybliżamy zakres zagadnień, na których skupimy
się w pracy.

\section{Co to jest test?}
\label{test}

W artykule \cite{good-test} Cem Kaner zastanawia się, jakimi cechami powinien
charakteryzować się dobry test.  Odpowiedź na to pytanie wymaga najpierw
zdefiniowania pojęcia samego testu. Bob Binder (1999) robi to w ten sposób:

\begin{quote}
Przypadek testowy zawiera opis początkowego stanu testowanego obiektu oraz jego
środowiska, zestawu danych lub warunków wejściowych oraz oczekiwanego
rezultatu. Rezultat ten określa co testowany obiekt powinien zwrócić w
odpowiedzi na dane wejściowe, jakie powinien wygenerować komunikaty oraz
końcowy stan obiektu oraz środowiska.
\end{quote}

Test opisuje zatem pewne oczekiwane zachowanie testowanego obiektu w zadanych
warunkach. Istotne jest, że testowanego obiektu nie rozpatruje się w izolacji,
lecz bierze się pod uwagę także jego środowisko. Test ma też wyraźnie określony
początek, czyli moment, w którym zaczynamy w znanym, prawidłowym stanie, oraz
koniec, kiedy to powinniśmy zweryfikować otrzymany stan, porównując go z
założeniami testu.

Powyższa definicja jest bardzo popularna i mówi, co wchodzi w skład opisu
przypadku testowego. Pozbawiona jest jednak wymiaru praktycznego, czyli
przyczyny, dla której przeprowadzamy test, a zatem podstawy do oceny wartości
testu. Kaner \cite{good-test} podaje więc następujące znaczenie dla pojęcia
przypadku testowego:

\begin{quote}Przypadek testowy to pytanie zadawane na temat programu. Celem
wykonania testu jest zdobycie informacji. Na przykład, czy program spełni
warunek testu.
\end{quote}

Z tak sformułowanej definicji wynika, że dobry jest taki test, który dostarcza
nowych informacji na temat testowanego obiektu. Kryteria oceny konkretnego
przypadku testowego zależne są od jego rodzaju. Innych cech wymaga się od
testów regresyjnych, a innych od testów użytkownika.

\section{Dlaczego testujemy}
\label{dlaczego-testujemy}

Oprogramowanie testuje się, żeby sprawdzić zgodność jego działania ze
specyfikacją. Twórcy zależy na tym, żeby zminimalizować liczbę swoich błędów,
tj. zapewnić, że jak największa część wymaganej funkcjonalności działa zgodnie
z planem. Odbiorca natomiast chciałby potwierdzenia, że otrzymuje produkt,
jakiego oczekiwał. Pod tymi słowami kryje się za każdym razem inny konkret,
któremu się przyglądamy, jednak kilka ogólnych cech pozostaje niezmiennych.

Pierwszą taką cechą jest weryfikacja mierzalnej wartości. Testy powstają w celu
sprawdzenia czy otrzymane wyniki spełniają określone kryteria. Wymagane jest
więc określenie jakich wartości oczekujemy od poszczególnych czynników, w
przeciwnym razie test nie dawałby odpowiedzi zadane na pytanie. Biorąc za
przykład popularny ostatnio ,,szybki Internet'' łatwo pokazać, że samo nazwanie
czegoś szybkim nie przedstawia żadnej cennej informacji, gdyż mówiąc potocznie,
dostawcy usług zawsze dostarczają najszybszy Internet, a mimo to z roku na rok
udaje się zapewnić jeszcze szybsze łącza. 

Obiektywne sformułowanie przedmiotu testu wymienia nie tylko badaną wielkość,
ale również oczekiwaną wartość. Mówienie o szybkości transferu ma sens, kiedy
padają konkretne liczby, ponieważ wtedy można je porównać z przewidywaniami i
stwierdzić czy dana szybkość nas zadowala. Może zdarzyć się, że taka wartość
odniesienia nie istnieje. Przy pierwszym pomiarze czasu wykonania nowego
algorytmu możemy tylko zgadywać lub subiektywnie oceniać go w świetle podobnych
algorytmów. W kolejnych pomiarach dysponujemy już jednak poprzednią wartością i
możemy wnioskować z jej pomocą. Niezmienny jest jednak fakt, że sprawdzamy
wielkość, którą można zmierzyć i nasze pomiary nie są zaburzone naszą osobistą
oceną.

Możliwość dokonania kolejnego pomiaru jest drugą bardzo istotną cechą testu.
Dzięki temu jesteśmy w stanie ocenić jak na wyniki wpływają takie czynniki jak
sprzęt czy zmiany w oprogramowaniu. Istnieje szereg testów, których charakter
uniemożliwia ich powtórzenie lub czyni je kosztownym. Na szczęście sprzęt
sieciowy nie ulega zniszczeniu w czasie większości testów. Uruchomienie tego
samego testu na różnego rodzaju urządzeniach pozwala stwierdzić czy tworzone
rozwiązanie jest przenośne, czy się skaluje, czy sprawdza się w specyficznych
warunkach itp. W zastosowaniach związanych z sieciami komputerowymi tego typu
testy są szczególnie istotne ze względu na różnorodność dostępnych urządzeń i
protokołów.

Tworzenie, poprawianie i rozbudowywanie oprogramowania wiąże się nieodłącznie
ze zmianami w kodzie. Możliwość wielokrotnego testowania danej funkcjonalności
pozwala ocenić ją w świetle wprowadzanych zmian. Najpierw można przekonać się o
tym, że pożądana cecha została osiągnięta. Następnie, w przypadku poprawek
istniejącego produktu, możemy przekonać się, że problemy zostały usunięte, a
także, że ich eliminacja nie zaburzyła innych komponentów. To samo dotyczy nowo
dodanych funkcjonalności. Mamy również możliwość oceny wpływu zmian na
wydajność i to przy systematycznym wykonywaniu testów na przestrzeni życia
całego projektu.

Publikacje na temat automatyzacji testów \cite{good-test,snake-oil} zwracają
jednak uwagę, że istnieją dobre testy, które informacji o produkcie dostarczają
tylko za pierwszym razem, a ich kolejne wykonania nie zwiększają już naszej
wiedzy o testowanym obiekcie. Z tego powodu zwykle nikt nie jest zainteresowany
ich ponownym wykonaniem.

\section{Testy oprogramowania sieciowego}
\label{testy-aplikacji-sieciowych}

W sieciach komputerowych oprogramowanie wykorzystuje się na różnych warstwach
modelu OSI powierzając mu różne zadania i inaczej je implementując. Od każdego
składnika sieciowego stosu oczekujemy poprawnej pracy, którą można weryfikować
testami. Inaczej wyglądają testy protokołu CSMA/CD, inaczej protokołu TCP,
wreszcie zupełnie inne są testy aplikacji synchronizującej kalendarz z
urządzeniem mobilnym. Z drugiej strony często można znaleźć elementy wspólne
pomimo tego, że badane implementacje realizują zupełnie inną funkcjonalność.

W dalszych rozważaniach skupimy się na podziale testów ze względu na rodzaj
obserwowanych wielkości, ponieważ niezależnie od warstwy, sposób ich pomiaru
jest podobny. Wyróżniliśmy następujące rodzaje testów:
\begin{itemize}
  \item wymienianych PDU,
  \item sekwencji komunikatów,
  \item wydajności transmisji.
\end{itemize}

Pierwszy rodzaj dotyczy poprawności budowy komunikatów wymienianych między
urządzeniami. Są to testy mające na celu sprawdzić czy przesyłane dane
odpowiadają założeniom.  Badane są takie wielkości jak: długość PDU, zgodność
sumy kontrolnej, poprawność kodowania numeru wersji itp. Kontrola jakości na
tym etapie ma na celu zweryfikowanie, czy wygenerowane bity reprezentują PDU
zgodne ze specyfikacją. Od wykorzystywanych tu narzędzi wymaga się, aby
umożliwiały sformalizowanie opisu zawartego w dokumentacji do postaci, którą
można algorytmicznie porównać z obserwowanymi PDU.

Kiedy operujemy poprawnymi komunikatami, należy zadbać o poprawność ich
sekwencji. Skuteczna komunikacja najczęściej wymaga zachowania pewnej
kolejności i rodzaju przesyłanych PDU. Testy sprawdzają czy obserwowane grupy
komunikatów odpowiadają tym ze specyfikacji, np. czy numery potwierdzeń
odpowiadają numerom wysyłanych danych, czy na generowane zapytania otrzymujemy
odpowiedzi, czy komponent poprawnie reaguje na utracone lub przekłamane dane
itd. Od narzędzi wymaga się już nie tylko parsowania PDU, ale też
interpretowania ich zawartości i podążania za obserwowanym, globalnym stanem
połączenia.

Wydajność transmisji dotyczy między innymi osiąganych przepustowości, reakcji
na zatory, rywalizacji z innymi przepływami, jakości łączy fizycznych i innych
czynników mających wpływ na odczuwalną jakość połączenia. Chociaż wystarczą tu
najprostsze narzędzia (niemal każdy klient HTTP jest w stanie wyświetlić
uzyskaną przepływność), jest to najtrudniejsza płaszczyzna testów. O ile w
przypadku obserwacji pojedynczych PDU i ich sekwencji większość testów można
automatycznie wygenerować z dokumentacji protokołu, to zbadanie kwestii
wydajności jest bardzo trudne bez udziału człowieka.

W tego typu testach sama implementacja odgrywa istotną rolę, ale ogromne
znaczenie ma też wpływ środowiska i to użytkownik musi zadecydować o tym, jakie
warunki chcemy badać, bo tylko on zna przeznaczenie tworzonego oprogramowania.
Test w tym przypadku nie polega na zatwierdzeniu lub odrzuceniu pojedynczego
przypadku, a na analizie wielokrotnie powtarzanych eksperymentów i odniesieniu
wyników do teoretycznych założeń. Wiedza ekspercka jest tu nieodzowna.
Narzędzia do testowania wydajności nie powinny więc wyręczać człowieka, ale
wspierać go ułatwiając konfigurację środowiska, obsługę wielu urządzeń
jednocześnie i katalogowanie wyników.

\section{Testy w warunkach rzeczywistych a symulacje}
\label{testy-w-warunkach-rzeczywistych-a-symulacje}

Jest jasne, że eksperymenty najwygodniej przeprowadza się w sterylnych
warunkach laboratorium. Błędem jest jednak oczekiwanie, że produkt będzie
zachowywał się identycznie w ,,normalnym'' użytkowaniu, a inżynieria oprogramowania
zaleca nawet wykonywanie testowej instalacji wdrożeniowej, aby zaobserwować
powstające różnice. Testy wykonywane w warunkach rzeczywistych mają zarówno
wady jak i zalety.  Wracając do omówionych powyżej rodzajów testów, można
powiedzieć, że w zależności od testu pożądane będą różne warunki jego
wykonania.

Aby sprawdzić czy algorytm generuje poprawne PDU wygodniej jest skorzystać
ze środowiska testowego, debuggera czy symulatora niż przeprowadzać test w
sieci. Opóźnienia związane z realną transmisją są niepotrzebne, a nawet
niepożądane. Możemy nawet uruchomić algorytm osobno, poza stosem sieciowym, i
analizować jego działanie niezależnie. W przypadku sekwencji komunikatów
również wystarczy symulowanie uczestników komunikacji, gdyż zakładając poprawne
działanie pozostałych elementów sieci, skupimy się w ten sposób na danym
algorytmie.

Test w warunkach rzeczywistych zawsze będzie wartościowym uzupełnieniem,
ponieważ na symulatorze możemy zapomnieć o takich problemach jak przekłamania
bitów czy gubienie PDU, a tworzone oprogramowanie powinno być na te zjawiska
odporne. Najlepszym scenariuszem byłoby testowanie dwóch powyższych
jednocześnie z wydajnością, ale jednoczesna analiza może prowadzić do
otrzymania złych wyników. Wydajność może być niższa od rzeczywistej z powodu
narzutu związanego ze sprawdzaniem komunikacji.

Pomiar wydajności w warunkach symulowanych dostarcza cennych informacji na
temat wymagań stawianych procesorowi czy pamięci. Trzeba mieć jednak na uwadze,
że otrzymywane wyniki mają szczególny charakter i nie należy ich przekładać na
oczekiwane zachowania w rzeczywistych sieciach. Dostępna obecnie moc
obliczeniowa pozwala symulować wiele czynników występujących w prawdziwych
sieciach, można więc coraz więcej testów przeprowadzać w środowiskach
wirtualnych. Uważamy jednak, że mnogość czynników, które trzeba uwzględnić,
wciąż przemawia na korzyść testów w warunkach rzeczywistych. Te czynniki to
między innymi:
\begin{itemize}
\item zawodność sprzętu,
\item wpływ innych użytkowników,
\item opóźnienia,
\item problem synchronizacji,
\item kwestie bezpieczeństwa.
\end{itemize}

Mimo, że powinno się myśleć o tych problemach jak o przeszkodach, to właśnie
fakt ich występowania jest powodem, dla którego test przeprowadzamy. Zjawiska
te, z natury nieprzewidywalne, uderzają w założenia o powtarzalności testu. Z
tego powodu należy monitorować i w miarę możliwości odnotowywać ich wpływ, aby
w zebranych wynikach móc poszukiwać relacji tłumaczących ewentualne zmiany w
obserwowanym zachowaniu. Trzeba też pamiętać, że zbierane wyniki nabierają
charakteru statystycznego i aby stały się wiarygodne, testy należy wielokrotnie
powtarzać.

\section{Podsumowanie}
\label{testowanie-podsumowanie}

Tworząc produkt, staramy się zapewnić jak najwyższą jakość. Testowanie nie
zapewnia jakości \cite{good-test}, daje jednak odpowiedzi na pytania, dzięki
którym możemy określić osiągniętą jakość.

Dobry test dostarcza informacji na temat testowanego produktu. Aby uzyskiwana
informacja była wartościowa, obserwowane cechy muszą być mierzalne i posiadać
wartość odniesienia.  Wyniki testów w warunkach rzeczywistych są często
zaburzone i nabierają wartości po wielokrotnym powtórzeniu testu, stąd częsta
konieczność ich automatyzacji.

W dalszej części pracy nie będziemy poruszać tematyki tworzenia dobrych testów,
skupimy się natomiast na automatyzacji ich przeprowadzania.

\end{document}
