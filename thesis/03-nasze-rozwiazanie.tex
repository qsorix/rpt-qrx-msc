\documentclass[00-praca-magisterska.tex]{subfiles}
\begin{document}

\chapter{NAZWA}

\FIXME{
Podzielić ten rozdział na mniejsze - mniej pojemne.
}

W tym rozdziale prezentujemy stworzone przez nas narzędzie NAZWA. Jego zadaniem
jest automatyzacja powtarzających się czynności występujących przy
przeprowadzaniu testów w środowiskach rozproszonych w warunkach rzeczywistych.
Samo zaprojektowanie testu i stworzeniu programów potrzebnych do jego
przeprowadzenia pozostaje w kwestii użytkownika. Przykładowe konfiguracje i
scenariusze użycia zostaną przedstawione w \fixme{rozdziale JAKIMŚTAM}.

\section{Zastosowania}

NAZWA zostało stworzone z myślą o testerach, zespołach badawczych oraz
studentach kierunków informatycznych, zajmujących się tworzeniem oprogramowanie
sieciowe lub przeprowadzaniem eksperymentów w sieciach komputerowych. Może być
ono również przydatne dla prowadzących zajęcia praktyczne, przygotowujących
ćwiczenia w takich środowiskach.

Tworząc NAZWA skupiliśmy się na kilku przypadkach zastosowań, które pojawiły
się w czasie naszych zajęć laboratoryjnych z różnych przedmiotów. Na uwadze
mieliśmy trzy konkretne scenariusze omówione poniżej.

Potrzebowaliśmy narzędzia, które zautomatyzuje najczęściej wykonywane
czynności: skonfiguruje maszyny, przeprowadzi testy, zapamięta wyniki i
przywróci pierwotną konfigurację.

\FIXME{
Pierwszy scenariusz nie pasuje do pozostałych. Jest zbyt ogólny. Zrobić to lepiej.
}

Najprostszy scenariusz ma miejsce w czasie tworzenia oprogramowania typu
klient-serwer. Testując działanie na dwóch maszynach, najczęściej korzystamy z
komputera, na którym trwa tworzenie oprogramowania, i innej wybranej maszyny
będącej w stanie pełnić rolę serwera (lub klienta, dalej dla uproszczenia opisu
zakładamy jednak, że jest to serwer).

Zadanie programu polega tutaj na:
\begin{enumerate}
\item przesłaniu aktualnej implementacji serwera na wyznaczone urządzenie,
\item uruchomieniu serwera i klienta,
\item zakończeniu serwera po wykonaniu testu,
\item zapamiętaniu wyników pracy obu komponentów,
\item usunięcie plików serwera ze zdalnej maszyny.
\end{enumerate}

Drugi scenariusz dotyczy pomiaru szybkości transferu danych przy użyciu
protokołu DCCP (Datagram Congestion Control Protocol\footnote{\fixme{Trzeba
ustalić co robimy ze skrótami. Może jednak słownik?}}) oraz wpływu innych
transmisji na tę szybkość. Sposób pomiaru jest prosty. Wykorzystujemy program
\code{iperf}, który umożliwia uruchomienie serwera i klienta wybranego
protokołu. Klient transmituje do serwera strumień losowych danych korzystając
ze wskazanego protokołu transportowego i zapamiętuje uzyskaną szybkość
transmisji. Dodatkowo, przy użyciu reguł \code{iptables} mierzy się ilość
pakietów i bajtów całego ruchu sieciowego.

Stworzyliśmy kilka różnych testów badających m.in.: samodzielną pracę DCCP,
wpływ transmisji TCP i UDP na pracę DCCP, porównanie DCCP z TCP i UDP, itd.
Różniły się one kolejnością i momentami, w których na uczestniczących w teście
urządzeniach należało uruchomić lub zakończyć \code{iperf}.

Aby zautomatyzować te testy, program musi:
\begin{enumerate}
\item korzystając z interfejsu \code{sysctl} skonfigurować parametry DCCP,
\item stworzyć reguły \code{iptables} do mierzenia ruchu,
\item przeprowadzić synchronizację, 
\item rozpocząć test,
\item w wyznaczonych momentach rozpocząć lub zakończyć działanie \code{iperf},
\item zbierać wartości liczników \code{iptables},
\item zapamiętać wszystkie uzyskiwane wyniki,
\item przywrócić opcje DCCP i konfigurację \code{iptables}.
\end{enumerate}

Ważne jest też, żeby w czasie testu program nie przesyłał żadnych danych, aby
nie wpływał na uzyskiwane wyniki.

Trzeci scenariusz, który mieliśmy na uwadze, to ćwiczenie laboratoryjne z
Systemów Peer-to-Peer. Test polega na pomiarze czasu dystrybucji pliku w sieci
BitTorrent. Klienci mają rozpocząć ściąganie w tym samym momencie, a test należy
zakończyć kiedy wszyscy będą posiadać pełny plik. Interesuje nas, ile każdy
klient wysłał danych i ile trwała pełna dystrybucja pliku. Zadana topologia
urządzeń to dwie sieci IP po cztery urządzenia, połączone routerem sztucznie
generującym opóźnienia.

Program w tym teście:
\begin{enumerate}
\item do każdego uczestnika wysyła plik torrent,
\item konfiguruje interfejsy routera,
\item konfiguruje adresy sieciowe uczestników,
\item jednocześnie uruchamia klientów sieci BitTorrent,
\item oczekuje aż każdy otrzyma pełny plik,
\item zatrzymuje klientów,
\item zapamiętuje wyniki,
\item przywraca konfigurację.
\end{enumerate}

Warto zauważyć, że w każdym z powyższych scenariuszy test kończy się w innym
momencie. W pierwszym jest to moment, kiedy pracę zakończy dany program. Testy
z drugiego scenariusza kończą się w określonym momencie czasowym. W ostatnim
wypadku decyzja o zakończeniu jest podejmowana przez wszystkich uczestników.

\section{Wymagania}

Lista poniżej zbiera wymagania stawiane przed programem we wprowadzeniu oraz te
wynikające z omówionych przed chwilą scenariuszy. W skład możliwości musi wchodzić:
\begin{itemize}
\item definiowanie testu,
\item łączenie ze zdalnymi urządzeniami,
\item konfiguracja zdalnych urządzeń,
\item przesyłanie zasobów\footnote{np.~pliki konfiguracyjne wykonywanych programów}  wymaganych w testach,
\item uruchamianie programów,
\item pobieranie wyników,
\item katalogowanie wyników wielu testów,
\item synchronizacja startu testu,
\item rozłączanie na czas wykonywania testu,
\item zakończenie testu w określony sposób:
  \begin{itemize}
  \item konkretny czas,
  \item kooperatywna decyzja uczestników testu,
  \item wyznaczony host kończy test.
  \end{itemize}
\end{itemize}

Powyższe wymagania mieliśmy na uwadze projektując projekt. Będziemy do nich
powracać w pozostałej treści pracy, żeby wykazać, iż zostały one spełnione.

\section{Założenia}

Realizacja wymienionych w poprzedniej części wymagań wiązała się z podjęciem
wielu decyzji projektowych, które miały istotny wpływ na ogólny obraz tworzonego
programu.  Podejmując je kierowaliśmy się głównie chęcią stworzenia wygodnego i
prostego narzędzia.

\paragraph{Użytkownik wie, co robi.} Przyjęliśmy więc, że nie będziemy
wprowadzać rygorystycznej kontroli poprawności konfigurowanych akcji kosztem
funkcjonalności. NAZWA stara się ograniczać użytkownika w jak najmniejszym stopniu,
dzięki czemu może być wykorzystany w większej liczbie przypadków.

\paragraph{Bezpieczeństwo jest adekwatne do zagrożeń.} Aby możliwe było
przeprowadzenie pewnych testów, na urządzeniach wymagany jest dostęp w trybie
administratora. Ponieważ polecenia realizujące test przekazywane są zdalnie,
istnieje ryzyko wykorzystania ich do wykonania dowolnych komend jako
administrator. Nie niesie to jednak zagrożeń dla bezpieczeństwa gdyż środowisko
przeprowadzania testu zwykle odpowiada jego wymaganiom dotyczącym uprawnień w
dostępie.

Urządzenia w laboratoriach są przeznaczone do wykonywania na nich
eksperymentów.  Ich pierwotna konfiguracja jest po wykonaniu testów
przywracana. Sieci takie są najczęściej odizolowane, a wieć szansa zdalnego
dostępu do tego typu sieci jest znikoma.

Sieci domowe składają się z urządzeń, których administratorem jest właściciel i
najczęściej jest to ta sama osoba, która wykonuje test. Od sieci laboratoryjnych
konfiguracje takie różnią się zwykle faktem połączenia z Internetem i
występowaniem prywatnych danych. Dostęp z zewnątrz zwykle ograniczony jest przez
firewall routera. Użycie naszego programu nie powinno więc zwiększać
istniejącego ryzyka, w przypadku zastosowania go na urządzeniu pełniącym jego
rolę. Jednocześnie mamy pełne zaufanie do użytkowników sieci lokalnej.

Kwestie bezpieczeństwa są istotne w przypadku zastosowania naszego
oprogramowania w sieciach produkcyjnych jak sieć akademicka lub firmowy
intranet. W tego typu sieciach administracją zajmują się wyznaczone osoby.
Użytkownicy nie mają uprzywilejowanego dostępu do urządzeń i zwykle mogą
korzystać tylko z wyznaczonych systemów, na których muszą się uwierzytelniać.
Użytkownikom często nie wolno instalować własnego oprogramowania, a komunikacja
sieciowa jest ograniczana. W takich warunkach korzystanie z naszego programu
jest technicznie ograniczone do wykonywania czynności, które użytkownik ma prawo
wykonywać. 

\FIXME{
Wyjaśnić lepiej o co chodzi z bezpieczeństwem w akapicie poniżej.
}

Zadbaliśmy jednak o to, aby automatyzacja takich czynności jak uwierzytelniane
nie naruszała bezpieczeństwa poufnych informacji. Mamy tu na myśli tajne dane
występujące w powszechnych sposobach uwierzytelniania jak hasła czy klucze
szyfrujące.

\paragraph{Architektura Master-Worker.} Ponieważ wymagane jest, aby dało się
wykonywać test w sytuacji kiedy nie ma połączenia między urządzeniem, z którego
uruchamiamy test, a innym w teście uczestniczącym, konieczne było wprowadzenie
dodatkowej aplikacji pomocniczej. Wyróżniamy więc aplikację (Master) nadzorującą
przebieg testu, oraz aplikacje wykonujące go (Worker), zainstalowane na
występujących w teście urządzeniach.

\FIXME{
Trzeba to napisać mniej ogólnie, a do tego trzeba ustalić co jak się nazywa i
używać konkretnych nazw i sformułowań: narzędzie, aplikacja, program...
}

Wprowadzenie takiej architektury powoduje, że instalacja aplikacji wykonującej
testy (Worker) zajmuje więcej czasu, trzeba ją bowiem przeprowadzić na
wszystkich systemach.  Jest to jednak konieczne, w celu osiągnięcia
funkcjonalności wymaganej w pewnych scenariuszach testów, jak również przydatne
ze względów bezpieczeństwa. Aplikacja nadzorująca (Master) umożliwia również
współpracę z urządzeniami bez zainstalowanego modułu Worker\footnote{Jak
np.~routery sprzętowe, gdzie instalacja własnego oprogramowania nie jest
możliwa.}, ale może wtedy nie być możliwe wykonanie pewnych testów.
\fixme{Tutaj przykład musi być.}

\paragraph{Synchronizacja urządzeń nie zmienia wskazań ich zegarów.}
Najprostszym rozwiązaniem problemu synchronizacji byłoby wykorzystanie protokołu
NTP do ustawienia czasu systemowego i następnie korzystanie z lokalnych wskazań
tych zegarów. Takie wyjście ma jednak dwie wady. Po pierwsze zmiana zegara nie
jest dostępna na wszystkich systemach. Po drugie, zmiana wskazań zegara w czasie
pracy systemu mogłaby zaburzyć pracę innych uruchomionych programów. Z tego
powodu prościej i bezpieczniej jest sprawdzić czy urządzenia są zsynchronizowane
i odmówić pracy w przeciwnym razie, niż automatycznie tę synchronizację
przeprowadzać.

\FIXME{
Więcej i dokładniej o synchronizacji.
}

\paragraph{Wszystkie wyniki są cenne.} Ponieważ obecnie przechowywanie dużych
ilości danych nie sprawia problemu, w czasie testu staramy się zebrać jak
najwięcej informacji. Ostatecznie to użytkownik decyduje o tym, co zostanie
zapamiętane, ale naszą myślą przewodnią było umożliwienie zapisania wszystkich
występujących w teście danych, takich jak wyjście programów, wytwarzane pliki,
kody wyjścia uruchamianych poleceń itp.

Ponadto staraliśmy się ułatwić katalogowanie danych, gdyż w przypadku
wielokrotnych uruchomień testu, szybko zbierają się ich duże ilości. Z tego
powodu do ich przechowywania korzystamy z bazy danych SQLite. Jest to naszym
zdaniem odpowiedni kompromis między możliwościami bazy danych a wygodą
przechowywania wyników w zwykłych plikach.

\paragraph{Narzędzie musi być elastyczne.} W czasie pracy zauważyliśmy, że
scenariusze różnego rodzaju testów wymagają różnych podejść. Projektując
aplikację uwzględniliśmy rozmaite przypadki, aby żadnego nie dyskryminować.
Zdajemy sobie jednak sprawę, że stworzenie gotowego narzędzia do przeprowadzania
wszystkich testów nie jest możliwe. Z tego powodu stworzyliśmy produkt
elastyczny, którego funkcjonalność w wielu miejscach można rozszerzać
samodzielnie. Dzięki temu możliwa jest obsługa różnego rodzaju urządzeń i
topologii sieciowych, jak również sposobów przeprowadzania testu.

\paragraph{Użytkownicy znają język Python.} Język Python jest wybranym przez nas
językiem implementacji jak i konfiguracji programu. Z tego powodu od
użytkowników wymagana jest jego podstawowa znajomość. Uważamy, że nie jest to
utrudnienie, ponieważ alternatywą byłoby wymaganie, aby użytkownik nauczył się
stosowanej przez nas, nowej składni plików konfiguracyjnych, a znajomość podstaw
języka Python jest bardziej uniwersalna.

Wybór tego, a nie innego języka Python był podyktowany jego popularnością, mamy
więc nadzieję, że spora część użytkowników odbierze to założenia jako zaletę, a
nie wadę produktu. Kolejną zaletą jest to, że jest on dostępny na wszystkich
popularnych systemach operacyjnych oraz domyślnie zainstalowany na większości
systemów Linuksowych.

\FIXME{Można dopisać jeszcze trochę na temat zalet pythona. W rozdziale o
konfiguracji też jest takie miejsce. Myślę, że tamten tekst można przenieść
tutaj i w opisie konfiguracji powołać się na założenia.

Myślę, że można napisać m.in., że python nie wymaga kompilacji, w związku z czym
instalacja jest prostsza, a pisanie nowych modułów szybsze.

Też o tym, że jest to język ze standardową biblioteką wielu funkcji, m.in.
obsługi sieci, co się może przydać.

Ponadto elementy funkcyjne języka oraz możliwość przeładowywania operatorów
pozwalają uzyskać zwięzłą składnię poleceń, przez co dobrze się nadaje do
pisania konfiguracji, bo kod jest krótki.
}

Poczyniliśmy także założenia mówiące o tym, czego program robić nie będzie.

\paragraph{Analizę wyników pozostawiamy ekspertom.} Program ma pomóc w
pozyskaniu wyników, ich analizę pozostawiamy użytkownikowi. Byłaby ona trudna ze
względu na to, że z każdego rodzaju testu wyniki miałyby inny charakter. Poza
tym programy produkują dane w różnych formatach i nie sposób tego wcześniej
przewidzieć. Dostępne są specjalistyczne programy służące do przetwarzania tego
rodzaju danych pomiarowych, uznaliśmy za zbędne i niepoprawne naśladowanie ich
funkcjonalności.

\paragraph{Nie mamy wpływu na fizyczną topologię sieci.} Z oczywistych powodów
program nie ma wpływu na sposób w jaki połączone są urządzenia w laboratorium. W
tworzonych testach zakłada się, że użytkownik wie, jaki wpływ na wyniki testu ma
stworzona przez niego sieć. Program nie stara się analizować zastanej topologii.

\paragraph{Środowisko testu jest jego cechą.} Przeprowadzając test w
rzeczywistej sieci prawdopodobnie celowo chcemy zbadać zachowanie implementacji
we współpracy z innymi uczestnikami sieci. Nasz program nie wymusza wyłączności
na komunikację sieciową ani nie monitoruje innych użytkowników sieci. Jeśli do
poprawnego przeprowadzenia pomiaru wymagane jest, aby testowany program był
jedynym użytkownikiem sieci, osoba wykonująca test sama musi o to zadbać.

\FIXME{
Problem 'urządzeń'. Trzeba to przedyskutować. Zrobię issue na githubie.
}

\paragraph{O \fixme{urządzeniach} zakładamy jak najmniej.} Program NAZWA nie
wymaga od \fixme{urządzeń} biorących udział w teście żadnej funkcjonalności.
Dzięki temu jesteśmy w stanie obsługiwać zarówno tanie urządzenia sieciowe, o
bardzo ograniczonych możliwościach konfiguracyjnych, jak i w pełni wyposażone
systemu Uniksowe czy dedykowane routery. To użytkownik decyduje o tym, co w
danym teście mają robić występujące w nim \fixme{urządzenia} i tym samym stawia
im wymagania dotyczące zarówno funkcjonalności, jak i bezpieczeństwa.

\end{document}
