(GoodTest.pdf)

What Is a Good Test Case?
Cem Kaner, J.D., Ph.D.
Florida Institute of Technology
Department of Computer Sciences
kaner@kaner.com
STAR East, May 2003


1:	Designing good test cases is a complex art. The complexity comes from three
	sources:
2:	Test cases help us discover information. Different types of tests are more
	effective for different classes of information.
	Test cases can be “good” in a variety of ways. No test case will be good in
	all of them.
3:	People tend to create test cases according to certain testing styles, such as
	domain testing or risk-based testing. Good domain tests are different from
	good risk-based tests.

1. Testy nie mogą być tworzone i oceniane automatycznie -- potrzebne
doświadczenie człowieka

2. Różne rodzaje testów dają różne informacje

3. Różne rodzaje testów są lepsze w zależności od zastosować -- dobre
narzędzie będzie wspierać różne style testowania.

	Bob Binder (1999, p. 47) defines test case:
4:	“A test case specifies the pretest state of the IUT and its environment, the test inputs or
	conditions, and the expected result. The expected result specifies what the IUT should
5:	produce from the test inputs. This specification includes messages generated by the IUT,
	exceptions, returned values, and resultant state of the IUT and its environment. Test cases
6:	may also specify initial and resulting conditions for other objects that constitute the IUT
	and its environment.”

4. W skad definicji testu wchodzi opis środowiska.

5. Test może określać generowane komunikaty, zwracane wyniki i końcowy stan
IUT i środowiska. Trzeba wszystkie te dane gromadzić.

6. Test może określać początkowe warunki, jakie musi spełniać środowisko.

7:	In my view, a test case is a question that you ask of the program. The point of running the test is
	to gain information, for example whether the program will pass or fail the test.

7. Celem wykonywania testu jest zdobycie odpowiedzi na (dowolne) pytanie o testowanym
programie. Skoro pytamy, nie zawsze z góry znamy odpowiedź.

8:	An important implication of defining a test case as a question is that a test case must be
	reasonably capable of revealing information.
9:	Under this definition, the scope of test cases changes as the program gets more
	stable.

8. Wynik testu musi być mierzalny/weryfikowalny, inaczej nie jest odpowiedzią
na pytanie.

9. Nie wszystkie testy warto powtarzać. Testy się zmieniają.

10:	Another implication of the definition is that a test is not necessarily designed to expose a defect.
	The goal is information. Very often, the information sought involves defects, but not always. (I
	owe this insight to Marick, 1997.) To assess the value of a test, we should ask how well it
	provides the information we’re looking for.

10. Test nie musi być ukierunkowany na znajdowanie błedów.

	For example, reliability is not just about the number of bugs in the product. It
	is (or is often defined as being) about the number of reliability-related failures that can be
	expected in a period of time or a period of use. (Reliability-related? In measuring
	reliability, an organization might not care, for example, about misspellings in error
	messages.) To make this prediction, you need a mathematically and empirically sound
11:	model that links test results to reliability. Testing involves gathering the data needed by
	the model. This might involve extensive work in areas of the product believed to be
	stable as well as some work in weaker areas. 

Aby ocenić niezawodność programu potrzebny jest matematyczny model oraz dane
pomiarowe zbierane w czasie testów => Testy są pomocne w ocenie niezawodności.

12:	Verify correctness of the product. It is impossible to do this by testing. You can prove
	that the product is not correct or you can demonstrate that you didn’t find any errors in a
	given period of time using a given testing strategy. 

12. Testy nie stwierdzają/dowodzą poprawności.

13:	More informative. A test provides value to the extent that we learn from it. In most cases,
	you learn more from the test that the program passes than the one the program fails, but
	the informative test will teach you something (reduce your uncertainty) whether the
	program passes it or fails.

13. Testy są pomocne podczas uczenia się o obserwowanym produkcie. Są więc cennym
elementem badań, i wartościowe niezależnie od pomyślności wyniku.

14:	For example, if we have already run a test in several builds, and the program
	reliably passed it each time, we will expect the program to pass this test again.
	Another "pass" result from the reused test doesn't contribute anything to our
	mental model of the program.

14. Powtarzanie testu nie zwiększa naszej wiedzy o programie.


15:	Appropriately complex. A complex test involves many features, or variables, or other
	attributes of the software under test. Complexity is less desirable when the program has
	changed in many ways, or when you’re testing many new features at once. If the program
	has many bugs, a complex test might fail so quickly that you don’t get to run much of it.
	Test groups that rely primarily on complex tests complain of blocking bugs. A blocking
	bug causes many tests to fail, preventing the test group from learning the other things
	about the program that these tests are supposed to expose. Therefore, early in testing,
	simple tests are desirable. As the program gets more stable, or (as in eXtreme
	Programming or any evolutionary development lifecycle) as more stable features are
	incorporated into the program, greater complexity becomes more desirable.

Złożoność testu odpowiada jego celowi. Program musi umożliwiać zarówno pracę z
prostymi, jak i złożonymi testami. Program musi pozwalać na błędy w czasie
testu i jego kontynuację.

16:	More likely to help the tester or the programmer develop insight into some aspect of the
	product, the customer, or the environment. Sometimes, we test to understand the
	product, to learn how it works or where its risks might be. Later, we might design tests to
	expose faults, but especially early in testing we are interested in learning what it is and
	how to test it. Many tests like this are never reused. However, in a test-first design
	environment, code changes are often made experimentally, with the expectation that the
	(typically, unit) test suite will alert the programmer to side effects.

16. Testy "badawcze" często nie są używane ponownie. Powinny być więc tanie do
zdefiniowania.

	Test Styles/Types and Test Qualities
	Within the field of black box testing, Kaner & Bach (see our course notes, Bach 2003b and
	Kaner, 2002, posted at www.testingeducation.org, and see Kaner, Bach & Pettichord, 2002) have
	described eleven dominant styles of black box testing:
	Function testing
	Domain testing
	Specification-based testing
	Risk-based testing
	Stress testing
	Regression testing
	User testing
	Scenario testing
	State-model based testing
	High volume automated testing
	Exploratory testing

↑ Można wymienić. Listy robią dużo treści ^^.

	Domain Testing
	The essence of this type of testing is sampling. We reduce a massive set of possible tests to a
	small group by dividing (partitioning) the set into subsets (subdomains) and picking one or two
	representatives from each subset.
17:	A good set of domain tests for a numeric variable hits every boundary value, including the
	minimum, the maximum, a value barely below the minimum, and a value barely above the
	maximum.
18:	The first time these tests are run, or after significant relevant changes, these tests carry a lot of
	information value because boundary / extreme-value errors are common.

17. Takie testy wymagają parametryzowania wartościami, dla jakich mają być
wykonane
18. Warto je powtarzać.

19:	Risk-Based Testing
	Imagine a way the program could fail and then design one or more tests to check whether the
	program will actually fail that in way.
	Risk-based tests tend to carry high information value because you are testing for a problem that
	you have some reason to believe might actually exist in the product. We learn a lot whether the
	program passes the test or fails it.

19. Testy zaplanowane tak, aby wykazać błędy w programie mogą być trudne do
automatyzacji. Test na routerze, który będzie powodował zawieszenie systemu
operacyjnego, nie będzie umożliwiał przywrócenia środowiska lub pobrania
wyników.

	Stress Testing
	There are a few different definition of stress tests.
	Under one common definition, you hit the program with a peak burst of activity and see it
	fail.
	IEEE Standard 610.12-1990 defines it as "Testing conducted to evaluate a system or
	component at or beyond the limits of its specified requirements with the goal of causing
	the system to fail."
	A third approach involves driving the program to failure in order to watch how the
	program fails. For example, if the test involves excessive input, you don’t just test near
	the specified limits. You keep increasing the size or rate of input until either the program
	finally fails or you become convinced that further increases won’t yield a failure. The fact
	that the program eventually fails might not be particularly surprising or motivating. The
	interesting thinking happens when you see the failure and ask what vulnerabilities have
	been exposed and which of them might be triggered under less extreme circumstances.
	Jorgensen (2003) provides a fascinating example of this style of work.

	These tests have high power.

20:	A good stress test pushes the limit you want to push, and includes enough diagnostic support to
	make it reasonably easy for you to investigate a failure once you see it.

20. Stress testing może wymagać środowiska sieciowego, aby np. obciążyć serwer
wieloma klientami (jedna aplikacja kliencka może nie dać rady). Bardzo istotne
są wartości metryk zbieranych w czasie testu.

	Regression Testing
21:	Design, develop and save tests with the intent of regularly reusing them, Repeat the tests after
	making changes to the program.
	Regression tests may have been powerful, credible, and so on, when they were first designed.
	However, after a test has been run and passed many times, it’s not likely that the program will
	fail it the next time, unless there have been major changes or changes in part of the code directly
	involved with this test. Thus, most of the time, regression tests carry little information value.
	A good regression test is designed for reuse. It is adequately documented and maintainable. (For
	suggestions that improve maintainability of GUI-level tests, see Graham & Fewster, 1999;
	Kaner, 1998; Pettichord, 2002, and the papers at www.pettichord.com in general). A good
	regression test is designed to be likely to fail if changes induce errors in the function(s) or area(s)
	of the program addressed by the regression test.

21. Powtarzanie testów regresyjnych jest clue ich istnienia.


	Scenario Testing
	A scenario is a story that describes a hypothetical situation. In testing, you check how the
	program copes with this hypothetical situation.
22:	The ideal scenario test is credible, motivating, easy to evaluate, and complex.
	In practice, many scenarios will be weak in at least one of these attributes, but people will still
	call them scenarios. The key message of this pattern is that you should keep these four attributes
	in mind when you design a scenario test and try hard to achieve them.

22. Dobry scenario test złożony. Fazy wykonania (triggers!) umożliwiają
wykonywanie kolejnych pod-scenariuszy (składanie schedules!)

23:	High-Volume Automated Testing
	High-volume automated testing involves massive numbers of tests, comparing the results against
	one or more partial oracles.
	The simplest partial oracle is running versus crashing. If the program crashes, there must
	be a bug. See Nyman (1998, 2002) for details and experience reports.

	Jorgensen (2002) provides another example of high-volume testing. He starts with a file
	that is valid for the application under test. Then he corrupts it in many ways, in many
	places, feeding the corrupted files to the application. The application rejects most of the
	bad files and crashes on some. Sometimes, some applications lose control when handling
	these files. Buffer overruns or other failures allow the tester to take over the application
	or the machine running the application. Any program that will read any type of data
	stream can be subject to this type of attack if the tester can modify the data stream before
	it reaches the program.

	Because the tests are not handcrafted, some tests that expose failures may not be
	particularly credible or motivating. A skilled tester often works with a failure to imagine
	a broader or more significant range of circumstances under which the failure might arise,
	and then craft a test to prove it.

23. Dobry pomysł na testy, niestety niezbyt uwzględniony przez Arete. Opisać
to w krytyce. ^^

